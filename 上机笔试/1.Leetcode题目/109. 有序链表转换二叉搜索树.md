#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

难度中等690

给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)

```
输入: head = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。
```

**题解**

不要被“平衡树”吓到。这和AVL树的实现没什么关系。其实，就是找到链表的中点，然后对左右分别构造二叉树，这样就完成了问题规模的缩小。

```
class Solution:
    def sortedListToBST(self, head) :
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)
        ########找中点#########
        slow = head
        fast = head.next
        slow_prev = None
        while slow and fast and fast.next:
            slow_prev = slow
            slow = slow.next
            fast = fast.next.next
            
        right_list = slow.next
        root = TreeNode(slow.val)
        if slow_prev: ##中点之前的一个节点
            slow_prev.next = None ##隔断
        else:
            head = None ##说明链表头就是中点！！！这个不要忘记
        left_root = self.sortedListToBST(head)
        right_root = self.sortedListToBST(right_list)
        root.left = left_root
        root.right = right_root
        return root
```

