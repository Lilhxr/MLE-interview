# 415. 大数相加[easy] & 51. 大数相乘



### 415. 大数相加 [easy]

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

```python
示例 1：

输入：num1 = "11", num2 = "123"
输出："134"
```



方法是，先把两个字符串都倒序，然后在短的后面补"0". 然后，每次都计算(num1+num2+carry)的值，最后别忘了如果carry=1需要进位！

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        ptr1 = len(num1)-1; ptr2 = len(num2)-1  ##从后向前
        carry = 0
        ans_stack = []
        while ptr1 >= 0 and ptr2 >= 0:
            digit = (carry + int(num1[ptr1]) + int(num2[ptr2])) % 10
            carry = (carry + int(num1[ptr1]) + int(num2[ptr2])) // 10
            ptr1 -= 1; ptr2 -= 1
            ans_stack.append(digit)
        while ptr1 >= 0:
            digit = (carry + int(num1[ptr1])) % 10
            carry = (carry + int(num1[ptr1])) // 10
            ptr1 -= 1
            ans_stack.append(digit)
        while ptr2 >= 0:
            digit = (carry + int(num2[ptr2])) % 10
            carry = (carry + int(num2[ptr2])) // 10
            ans_stack.append(digit)
            ptr2 -= 1
        if carry: ans_stack.append(carry)
        ans = ""
        for i in range(len(ans_stack)-1,-1,-1): ##倒序
            ans+=str(ans_stack[i])
        return ans
```



### 51. 大数相乘

##### 方法一： 暴力模拟竖式乘法

![fig1](https://assets.leetcode-cn.com/solution-static/43/sol1.png)

首先让num2变成那个短的字符串，然后对每个位置都计算乘法（后面补零），最后将这些结果全部加起来即可。

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"
        if len(num1) < len(num2):
            num1,num2 = num2, num1
        lena = len(num1)
        lenb = len(num2)
        ans = "0"
        for i in range(lenb-1,-1,-1):  ##从后向前遍历
            multiply_tmp = "0"*(lenb-1-i)
            carry = 0
            for j in range(lena-1,-1,-1):
                digit = str((int(num2[i])*int(num1[j])+carry)%10)
                carry = (int(num2[i])*int(num1[j])+carry) // 10
                multiply_tmp+=digit
            if carry:
                multiply_tmp+=str(carry)
            multiply_tmp = multiply_tmp[::-1]
            ans = self.addStrings(ans,multiply_tmp)
        return ans


    def addStrings(self, num1: str, num2: str) -> str:
        if len(num1) < len(num2):
            num1,num2 = num2,num1
        num1 = num1[::-1]
        num2 = num2[::-1]
        lena = len(num1)
        lenb = len(num2)
        for i in range(lena-lenb):
            num2+="0"
        print(num1,num2)
        ans = []
        carry = 0
        for i in range(lena):
            digit = (int(num1[i])+int(num2[i])+carry) % 10
            carry = int((int(num1[i])+int(num2[i])+carry) / 10 )
            ans.append(str(digit))
        if carry:
            ans.append(str(carry))

        return "".join(ans[::-1])
```

时间复杂度：O(mn+n^2)。其中 m 和 n 分别是 num1 和 num 的长度。这是因为需要从右往左遍历 num2, 对于num2的每一位，都需要和num1的每一位计算乘积，因此计算乘积的总次数是 mn。字符串相加操作共有 n 次，相加的字符串长度最长为 m+n，因此字符串相加的时间复杂度是 O(mn+n^2)。



**方法二：直接乘,后进位**

令 m 和 n 分别表示 num1和num2 的长度，那么我们可以先建立一个长为m+n-1的数组，来存储每一位的乘积加和：![img](https://pic1.zhimg.com/80/v2-cb716f02782f5e9575fe7124e5188fcd_1440w.jpeg)

然后，在这个数组上往前进位。

```python
def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"
        if len(num1) < len(num2):
            num1,num2 = num2, num1
        lena = len(num1)
        lenb = len(num2)
        ans = [0]*(lena+lenb-1)

        for i in range(lena):
            for j in range(lenb):
                ans[i+j] += int(num1[i])*int(num2[j])
        
        carry = 0
        ans_str = ""
        ptr = len(ans)-1
        while ptr >= 0:
            digit = (carry+ans[ptr]) % 10
            carry = (carry+ans[ptr]) // 10
            ans_str = str(digit)+ans_str
            ptr -= 1

        if carry > 0:
            ans_str = str(carry)+ans_str
     	return ans_str
```

