#### [814. 二叉树剪枝](https://leetcode-cn.com/problems/binary-tree-pruning/)

难度中等221

给你二叉树的根结点 `root` ，此外树的每个结点的值要么是 `0` ，要么是 `1` 。

返回移除了所有不包含 `1` 的子树的原二叉树。

节点 `node` 的子树为 `node` 本身加上所有 `node` 的后代。

 

**示例 1：**



```
输入：root = [1,null,0,0,1]
输出：[1,null,0,null,1]
解释：
只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。
```

题解：

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    dic = {} ##记录每个节点的子树和
    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.compute_tot(root)
        def helper(root): ##剪枝
            if not root:
                return root
            if self.dic[root] == 0: ##所在总和为0，剪枝之
                return None
            root.left = helper(root.left)
            root.right = helper(root.right)
            return root
        return helper(root)
        
    def compute_tot(self,root):  ##记录每个节点所对应子树之和
        if not root:
            return 0
        if root in self.dic:
            return self.dic[root]
        ans = root.val + self.compute_tot(root.left)+self.compute_tot(root.right)
        self.dic[root] = ans
        return ans
```

