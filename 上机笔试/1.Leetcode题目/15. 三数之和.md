### 两数之和 [easy]

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

解法：由于要求返回数组下标，所以断绝了我们排序的想法:(. 用哈希表即可解决，这样复杂度O(1). 

```python
class Solution:
    def twoSum(self, nums, target: int):
        dic = {}
        for i in range(len(nums)):
            if target - nums[i] in dic.keys():
                return [i,dic[target-nums[i]]]
            dic[nums[i]] = i
```





# 15. 三数之和

【关键词】：不可以包含重复 -> 可以通过排序来自然的去除重复解。

三数之和其实可以归约成“两数之和”。

对于两数之和，一种直观的想法是排序之后每次都做二分查找，但这样的复杂度是O(nlogn). 可以通过双指针的方法实现复杂度O(n)的方法。

**双指针解两数之和：**一个指针指向开头，一个指针指向结尾，如果num[left] + num[right] < target, 则左指针向右移动；否则，右指针向左移动。

但是本题的难点在于“**去重**”。首先，对于第一个数，如果nums[i] == nums[i-1], **那么能得到的三元组一定在前一个就已经得到了**！所以这种情况是要跳过i的。对于第二个和第三个数，为了对前后进行去重，应该在left<right的前提下，如果left的后一个数和left相等，就一直这么向右平A过去；如果right的前一个数和right相等，也这么向左平A过去。

![img](https://pic2.zhimg.com/80/v2-e8b9b3a2ad05838d49413909a71dfda3_1440w.png)

```python
class Solution:
    def threeSum(self, nums):
        nums = sorted(nums)
        ans_list = []
        for i in range(len(nums)): ##第一个指针
            left = i+1; right = len(nums)-1
            if i>=1 and nums[i] == nums[i-1]: ##前面的一定已经得到三元组了！
                continue
            while left < right:
                if nums[left]+nums[right]+nums[i] == 0:
                    while(left<right and nums[left]==nums[left+1]): ##向右平A过去
                        left=left+1
                    while(left<right and nums[right]==nums[right-1]): ##向左平A过去
                        right=right-1
                    ans_list.append([nums[left],nums[right],nums[i]])
                    left += 1
                    right -= 1
                elif nums[left]+nums[right]+nums[i] > 0:
                    right-=1
                else:
                    left += 1
        return ans_list
```

【易错点】在写nums[i] == nums[i-1]的时候，一定要保证i >= 1, 否则python有可能不报错，但是访问到了非法内存。
