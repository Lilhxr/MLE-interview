# 专题 - 单调栈



#### 双栈排序

题目描述：给定一个乱序的栈，设计算法将其升序排列。ps: 允许额外使用一个栈来辅助操作 

> 输入
> [4, 2, 1, 3]
> 输出
> [1, 2, 3, 4]

我们可以想到，通过辅助栈与乱序栈之间的“倒腾”，可以使辅助栈升序排列，返回辅助栈即可。

那么，如何“倒腾”就成为问题的关键。

其实，只需要把辅助栈设计成一个单调栈，每次由于push进来一个更小元素而pop出去的元素继续push进原来的栈中。

![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVFOuibeyibjsuYQLqXHTYIhJR8FWnSSX79hUWOBryWESDMcSCmeZqDoKJfEjV9DUfqQrpcNLBPibDeVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

"3"由于"1"的插入而不得不从单调栈移除。移除后继续插入原始栈。

```python
def stacksort(arr):  ##排序arr
    aux_stack = []
    while len(arr):
        top = arr[-1]
        arr.pop()
        if not len(aux_stack): ##辅助栈为空，
            aux_stack.append(top) ##直接push
        else:
            while len(aux_stack) and top < aux_stack[-1]: ##这一句是单调栈的核心。只要待插入元素<栈顶，就不停的pop栈顶。
                arr.append(aux_stack[-1])
                aux_stack.pop()
            aux_stack.append(top)
    print(aux_stack)
```



#### [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。

由于答案可能很大，因此 **返回答案模 10^9 + 7** 。

```python
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

解法：

首先，要找到每个元素的“辐射区域”。什么叫“辐射区域”呢？其实就是每个元素是最小值这个性质可以扩散到多远。要想做到这点，就需要从左到右找到右边第一个比此元素小的元素；从右到左找到左边第一个比此元素小的元素。

![rRuBI1.png](https://pic.leetcode-cn.com/1608858400-MFRUBI-rRuBI1.png)

这个就要由单调栈来做到了。方法和“每日温度”题类似。

```python
class Solution:
    def sumSubarrayMins(self, arr) -> int:
        #### 从左向右找第一个 < 当前元素的位置
        min_stack = []
        dp_left = [len(arr)]*len(arr)
        for i in range(len(arr)):
            if not len(min_stack):
                min_stack.append([arr[i],i])
            else:
                while len(min_stack) and min_stack[-1][0] >= arr[i]:##当前元素比栈顶还小
                    dp_left[min_stack[-1][1]] = i ##记录
                    min_stack.pop()
                min_stack.append([arr[i],i])

        dp_right = [-1]*len(arr)
        min_stack = []
        for i in range(len(arr)-1,-1,-1):
            if not len(min_stack):
                min_stack.append([arr[i],i])
            else:
                while len(min_stack) and min_stack[-1][0] > arr[i]:
                    dp_right[min_stack[-1][1]] = i
                    min_stack.pop()
                min_stack.append([arr[i],i])
                
        ans = 0
        for i in range(len(arr)):
            ans += (dp_left[i]-i)*(i-dp_right[i])*arr[i]
        return ans % 1000000007
```

