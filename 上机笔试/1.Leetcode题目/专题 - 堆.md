# 板子 - 堆

BBST的插入、删除、查找接口都只需O(logn)时间，但是BBST的功能超过优先级队列的需求。若只需查找极值元，则不必维护所有元素之间的**全序**关系。这样就引入了堆。

### 1. 手写堆

二叉堆其实就是一种特殊的二叉树（**完全二叉树**），只不过存储在数组里。

![img](https://pic2.zhimg.com/80/v2-325ba1af6b2f8e67d19a98b7583820cd_1440w.jpg)      

对于一般的二叉树，我们操作节点的指针；而对于完全二叉树，我们可以直接通过**数组索引**访问一个节点的parent, left son, 和right son. 和树的层次遍历一一对应：

![img](https://pic2.zhimg.com/80/v2-316c6df611d96b04ee0b215a3c3b1a7d_1440w.jpg)

最大堆的性质是：**每个节点都大于等于它的两个子节点**。 类似的，最小堆的性质是：**每个节点都小于等于它的子节点**。两种堆核心思路都是一样的，本文以最大堆为例讲解。(一个节点的左右孩子仍然是堆，每个节点都和自己的父亲、儿子满足堆序性，父亲永远大于儿子。)

对于一个最大堆，根据其性质，显然堆顶--也就是 arr[1] 一定是所有元素中最大的元素。

**【插入】：**先将词条e作为末尾元素接入向量，之后**上浮**之。

![img](https://pic3.zhimg.com/80/v2-355addfc2a147c91b59e4245ac592d9a_1440w.jpg)

![img](https://pic4.zhimg.com/80/v2-cc5a762bb1ca3d01f70dff35f2f25f6b_1440w.jpg)

**【删除】：**删除首个节点（最大的节点），并将最末的元素和根节点对换，然后不断下沉。

![img](https://pic4.zhimg.com/80/v2-1e372181c3cde6b48002925c31bc490b_1440w.jpg)

![img](https://pic1.zhimg.com/80/v2-7f1088d2be8e3c7dd6fa78968b51b7e4_1440w.jpg)下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要A和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和**其两个子节点**比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。

**【Floyd建堆方法】** 

- 暴力法：自上而下的上滤，逐一插入新的节点，新的节点在末尾逐渐上滤到顶端。最坏情况下，每个节点都需上滤至根，对于底层的那2/n个节点，最坏情况下需要上滤O(logn), 所以复杂度是O(nlogn)的。这样的速度，足以全排序了！![img](https://pic2.zhimg.com/80/v2-ba594962882b70859844dd13408537ad_1440w.png)
- Floyd建堆法：自下而上的下滤，相当于不断合并堆，一堆一堆凑成完整的大堆！这样，每个内部节点的时间复杂度正比于其**高度**而非**深度**！所有节点的高度总和是O(n)的。
- ![img](https://pic2.zhimg.com/80/v2-bac90fa40baedc448832c1023f36c593_1440w.png)

![img](https://pic2.zhimg.com/80/v2-ba468185d45385b334fd5142f8a3391e_1440w.png)

![img](https://pic1.zhimg.com/80/v2-1aa3bf49f678ba68ba10897c8ec5cd4d_1440w.png)

【堆排序代码：包含堆的板子和Floyd建堆法】

```python
class Heap:
    def __init__(self, nums,desc=False):
        self.heap = nums

    def top(self):
        if len(self.heap):
            return self.heap[0]
        return None

    def push(self, item):
        """
        添加元素
        第一步，把元素加入到数组末尾
        第二步，把末尾元素向上调整
        """
        self.heap.append(item)
        self._sift_up(len(self.heap) - 1)

    def pop(self):
        """
        弹出堆顶
        第一步，记录堆顶元素的值
        第二步，交换堆顶元素与末尾元素
        第三步，删除数组末尾元素
        第四步，新的堆顶元素向下调整
        第五步，返回答案
        """
        item = self.heap[0]
        self.heap[0], self.heap[-1] = self.heap[-1],self.heap[0]
        self.heap.pop()
        self._sift_down(0)
        return item


    def _sift_up(self, index):
        """
        向上调整
        如果父节点和当前节点满足交换的关系
        （对于小顶堆是父节点元素更大，对于大顶堆是父节点更小），
        则持续将当前节点向上调整
        """
        while index:
            parent = (index - 1) // 2

            if self.heap[parent] < self.heap[index]:
                break

            self.heap[parent],self.heap[index] = self.heap[index],self.heap[parent]
            index = parent

    def _sift_down(self, index):
        """
        向下调整
        如果子节点和当前节点满足交换的关系
        （对于小顶堆是子节点元素更小，对于大顶堆是子节点更大），
        则持续将当前节点向下调整
        """
        # 若存在子节点
        while index * 2 + 1 < len(self.heap):
            smallest = index
            left = index * 2 + 1
            right = index * 2 + 2

            if self.heap[left] < self.heap[smallest]:
                smallest = left

            if right < len(self.heap) and self.heap[right]<self.heap[smallest]:
                smallest = right

            if smallest == index:
                break
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]

class Solution:
    def sortArray(self, nums):
        ###Floyd建堆算法
        H = Heap(nums)
        for i in range(len(H.heap) // 2 - 1, -1, -1): ##对于每个内部节点，自下而上地
            H._sift_down(i) ##都进行下滤
        ans = []
        for i in range(len(nums)):
            ans.append(H.pop())
        return ans
```



### 2. python自带的堆

```python
###python中堆的接口：
import heapq
heapq.heapify(x) ###就地建堆，x是一个list。O(n)
headq.heappush(x,9) #### insert元素
heapq.heappop(x)  ## del 最小元素
x[0] ##直接访问最小元素
print(heapq.nlargest(3,x)) ## 找到最大的k个元素
print(heapq.nsmallest(3,x))
```

- 注意python没有大根堆的实现，需要转成负数然后调用**小根堆**接口。

- 如果 `heapq` 中放入的是**元组**，那么**元组的第一个元素会用于大小比较**。假设有这样一个问题，给定一个数组，返回前 `k` 小的数字所在数组中的位置。`Top k` 的问题的一个解法是使用堆，但是这里要求的是数字在数组中的位置而不是数字本身，所以不能直接将数组堆化，可以先将数组中的每个数字转换成一个包含2个元素的元组，元组的第一个元素是数字本身，第二个元素则是数字在数组中的位置。

- 元组的第二个元素也会被用于大小比较，比如我们希望按照出现频率**降序**排序，同等频率按照字典序**升序**排序的话，那么，可以写成`heapq.heappush(heap,[-dic[key],key])`.

- python中的 heapq 本身不支持自定义比较函数，可以通过重写对象的__lt__方法的方式来实现自定义比较函数。

  ```python
  import heapq
  class  P():
      def __init__(self,a,b):
          self.a = a
          self.b = b
      def __lt__(self, other):
          if self.b<other.b:
              return True
          else:
              return False
   
  a = P(3,1)
  b = P(2,3)
  c = P(10,0)
  d = P(3,1)
   
  h = []
  heapq.heappush(h,a)
  heapq.heappush(h,b)
  heapq.heappush(h,c)
  ```





-----

##### 239. 滑动窗口的最大值 [HARD]

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

```python
示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

思路：由于每次都要求**最大值**，所以很自然的想到**大根堆**。但是有一个问题，就是当窗口移动的时候，左窗口右移会导致有的元素被移出去，可是堆是不支持删除一个非根节点的。但是，其实并不用急着删除！

我们每次看根节点的时候，只需要判断它是不是在窗口范围内。如果不在范围内，就pop掉它，直到新的根在窗口范围内为止。

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if nums == []: ##空
            return []

        heap = []
        for i in range(k):
            heap.append((-nums[i],i)) ##(value,位置)
        heapq.heapify(heap)
        left = 0
        right = k
        ans = [-heap[0][0]]
        while right < len(nums):
            left += 1
            while len(heap) and heap[0][1] < left:  ##已经出了左窗口
                heapq.heappop(heap)
            heapq.heappush(heap,(-nums[right],right)) ##加入新的值
            right += 1
            ans.append(-heap[0][0]) ##此时的最大值
        return ans
```



