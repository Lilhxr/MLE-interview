# 板子 - 堆

### 1. 手写堆

```python
class heap:
    PQ = [-1]  ##索引0不用
    def parent(self,root):  ##找到root的父亲索引
        return int(root/2)
    def left_child(self,root):
        return root*2
    def right_child(self,root):
        return root*2+1
    def GetMax(self):
        return self.PQ[1]

    def insert(self,val):
        self.PQ.append(val)
        self.swim(len(self.PQ)-1)

    def swim(self,k): ###上浮第k个元素，以维护大顶堆性质(子强于父)
        while(k > 1): ##尚未到达根
            if self.PQ[k] > self.PQ[self.parent(k)]: #比自己父亲强
                self.PQ[k],self.PQ[self.parent(k)] = self.PQ[self.parent(k)],self.PQ[k] ##
                k = self.parent(k)
            else:  ##满足堆序型
                break
    def sink(self,k):  ##下沉第k个元素(不堪为父)
        while(self.left_child(k) < len(self.PQ)): ##不是叶子
            max_child = max(self.PQ[self.left_child(k)],self.PQ[self.right_child(k)])
            if self.PQ[k] > max_child: ##堪为父亲！
                break
            if max_child == self.PQ[self.left_child(k)]: ##最大的是左孩子
                self.PQ[k],self.PQ[self.left_child(k)] = self.PQ[self.left_child(k)],self.PQ[k]
                k = self.left_child(k) ##下沉
            else:  ##最大的是右孩子
                self.PQ[k], self.PQ[self.right_child(k)] = self.PQ[self.right_child(k)], self.PQ[k]
                k = self.right_child(k)  ##下沉

    def DelMax(self): ##删除并返回最大元素
        mmax = self.PQ[1]
        self.PQ[1] = self.PQ[len(self.PQ)-1]
        self.PQ.pop()
        self.sink(1)
        return mmax
```



要想改成小根堆，需要把一些>改成<, 还需要把max修改为min

### 2. python自带的堆

```python
###python中堆的接口：
import heapq
heapq.heapify(x) ###就地建堆，x是一个list。O(n)
headq.heappush(x,9) #### insert元素
heapq.heappop(x)  ## del 最小元素
x[0] ##直接访问最小元素
print(heapq.nlargest(3,x)) ## 找到最大的k个元素
print(heapq.nsmallest(3,x))
```

- 注意python没有大根堆的实现，需要转成负数然后调用小根堆接口。

- 如果 `heapq` 中放入的是**元组**，那么**元组的第一个元素会用于大小比较**。假设有这样一个问题，给定一个数组，返回前 `k` 小的数字所在数组中的位置。`Top k` 的问题的一个解法是使用堆，但是这里要求的是数字在数组中的位置而不是数字本身，所以不能直接将数组堆化，可以先将数组中的每个数字转换成一个包含2个元素的元组，元组的第一个元素是数字本身，第二个元素则是数字在数组中的位置。

- python中的 heapq 本身不支持自定义比较函数，可以通过重写对象的__lt__方法的方式来实现自定义比较函数。

  ```python
  import heapq
  class  P():
      def __init__(self,a,b):
          self.a = a
          self.b = b
      def __lt__(self, other):
          if self.b<other.b:
              return True
          else:
              return False
   
  a = P(3,1)
  b = P(2,3)
  c = P(10,0)
  d = P(3,1)
   
  h = []
  heapq.heappush(h,a)
  heapq.heappush(h,b)
  heapq.heappush(h,c)
  ```





-----

##### 239. 滑动窗口的最大值 [HARD]

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

```python
示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

思路：由于每次都要求**最大值**，所以很自然的想到**大根堆**。但是有一个问题，就是当窗口移动的时候，左窗口右移会导致有的元素被移出去，可是堆是不支持删除一个非根节点的。但是，其实并不用急着删除！

我们每次看根节点的时候，只需要判断它是不是在窗口范围内。如果不在范围内，就pop掉它，直到新的根在窗口范围内为止。

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if nums == []: ##空
            return []

        heap = []
        for i in range(k):
            heap.append((-nums[i],i)) ##(value,位置)
        heapq.heapify(heap)
        left = 0
        right = k
        ans = [-heap[0][0]]
        while right < len(nums):
            left += 1
            while len(heap) and heap[0][1] < left:  ##已经出了左窗口
                heapq.heappop(heap)
            heapq.heappush(heap,(-nums[right],right)) ##加入新的值
            right += 1
            ans.append(-heap[0][0]) ##此时的最大值
        return ans
```



##### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)(easy)

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

**示例 1：**

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

题解：最小的k个数，用大根堆来实现（在python中需用小根堆模拟）

```python
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        heap = []
        if k == 0:
            return []
        for i in range(k):
            heap.append(-arr[i]) ##大根堆
        heapq.heapify(heap)
        
        for i in range(k,len(arr)):
            if arr[i] < -heap[0]: ##比堆顶小
                heapq.heappop(heap) ##才能进堆
                heapq.heappush(heap,-arr[i])
        return [-_ for _ in heap]
```

