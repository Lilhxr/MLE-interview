#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**题解：**

贪心。记录能够到达的最远距离right_most，**遍历数组的时候顺便更新之**。遍历数组的时候，如果这个位置现在可以达到(<right_most), 那么就可以更新right_most了。什么时候发现right_most >= len(nums)-1,就说明能够到达最大长度，返回True。

```python
class Solution:
    def canJump(self, nums):
        right_most = 0
        for i in range(len(nums)):
            if i <= right_most: ###可以到达
                right_most = max(right_most,nums[i]+i)
            if right_most >= len(nums)-1:
                return True
        return False
```





#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

难度中等1544

给你一个非负整数数组 `nums` ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

题解：

用一个指针`right_most_prev`来记录上一次跳跃的最远位置，当我们遍历到位置i的时候，首先来更新现在能够跳到的最远位置`right_most`, 并且，如果现在的位置i就是上次跳跃的最远位置，那么就要开始下一次跳跃，把`right_most_prev`修改为现在能跳到的最远位置。

为什么遍历的i只能到len(nums)-2呢？这是因为如果到了len(nums)-1时就已经到最后一位了，不必开始不必要的跳跃。

（太难了....直接背下来吧）



```python
class Solution:
    def jump(self, nums) -> int:
        right_most = 0 ##记录现在能跳到的右边界
        step = 0 ##记录答案，跳跃的次数
        right_most_prev = 0 ##上次跳跃能跳到的范围
        for i in range(len(nums)-1):
            if i <= right_most: ###可以到达
                right_most = max(right_most,nums[i]+i) ##更新现在能够到达的最远位置
            if i == right_most_prev:##到了上次跳跃能跳到的右边界
                right_most_prev = right_most ##跳到这次能跳到的右边界
                step+=1 
                if right_most_prev >= len(nums)-1:
                    return step
        return 0
```

