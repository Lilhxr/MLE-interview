#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) & 701. 二叉搜索树中的插入操作

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)



题解：

不要去想迭代解法，因为迭代解法要考虑非常多的边界条件，还要记录predecessor和successor。所以，只需考虑递归解法。

那么，我们要想清楚递归解法的返回值是什么。在这里，递归解法输入一个根root，然后返回删除掉它之后的根root'. 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:

    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]: ##递归地删除，返回删除后的节点root
        if not root:
            return None
        if root.val == key: ###命中，删除之
            if not root.left and not root.right: ##叶子节点，直接删除掉
                return None 
            elif not root.right: ##直接用左节点来替换
                return root.left
            elif not root.left:
                return root.right
            else: ##右子树的第一个访问节点的左孩子变成根的左节点
                left_tree = root.left
                right_node = root.right
                while right_node.left:
                    right_node = right_node.left
                right_node.left = left_tree
                return root.right
        elif root.val < key:
            root.right = self.deleteNode(root.right,key) ##删除右子树
            return root
        else:
            root.left = self.deleteNode(root.left,key) ##删除左子树
            return root
```

当要删除的节点左右孩子都有的时候，删除它稍微一些困难。例如在下面这个例子中，删除节点4.

想要删除节点4，我们需要让6替代4的位置，并且把节点4的左孩子 -- 节点2移到节点6所在子树的最小值（节点5）的左子树. 如何找到这个最小值呢？其实就是一直向左孩子找。

![20220401_105200504_iOS.jpg](https://pic.leetcode-cn.com/1648814780-aBpncQ-20220401_105200504_iOS.jpg)





#### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

难度中等291

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

 ![img](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)

**示例 1：**

```
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
```

题解：

**二叉搜索树的搜索，等价于list的二分查找。**所以，我们按照这个找到**hot节点**，然后把val插入到hot节点的左边/右边即可。

```
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        hot = None
        tmp = root
        if root == None:
            return TreeNode(val)
            
        while tmp: ##二分查找
            hot = tmp
            if val < tmp.val:
                tmp = tmp.left
            else: ##val > tmp.val
                tmp = tmp.right
        ###########插入到hot的左/右孩子 #########
        if val < hot.val:
            hot.left = TreeNode(val)
            return root
        else:
            hot.right = TreeNode(val)
            return root
```

