# 专题 - 括号问题

- 栈
- 一维dp
- 二维dp

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（easy，栈）

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

```python
class Solution:
    def isValid(self, s: str) -> bool:
        right = ")}]"
        left = "({["
        dic = {"(":")","{":"}","[":"]"}
        stack = []
        for i in range(len(s)):
            if len(stack) == 0:   ##栈为空
                if s[i] in right:
                    return False
                else:
                    stack.append(s[i])
            else:         ##栈非空
                top = stack[-1]
                if top in right:    ##右括号
                    stack.append(s[i])
                else:             ##左括号
                    if s[i] == dic[top]:
                        stack.pop()
                    else:
                        stack.append(s[i])
        if len(stack) > 0:
            return False
        return True
```

【易错点】 注意最后要对stack做判空操作。



### 32. 最长有效括号[hard]，一维dp

我们定义 `dp[i]` 表示以下标 i 字符结尾的最长有效括号的长度。我们将 dp 数组全部初始化为 0 。显然有效的子串一定以 `)`结尾，因此我们可以知道以 `(` 结尾的子串对应的 dp 值必定为 0。

1. 当字符串形如 `……()`，我们可以推出：`dp[i]=dp[i−2]+2`.
2. 当字符串形如 `……))`，我们可以推出：
   当 i-1-dp[i-1]对应的字符是`(`, 则`dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2`

![img](https://pica.zhimg.com/80/v2-eb2a2ff70c8f4d3a7e53376f93291057_1440w.png)



```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        dp = [0]*(len(s))
        n = len(s)
        for i in range(n):
            if s[i] == ")": ##如果是左括号，必不能形成有效的括号子串，因而dp值为0
                if i>=1 and s[i-1] == "(": ###形如："...()"
                    if i >= 2:
                        dp[i] = dp[i-2]+2
                    else:
                        dp[i] = 2
                else:   ###形如 "...))"
                    if i >= 1 and i-1-dp[i-1] >= 0 and s[i-1-dp[i-1]] == "(":
                        dp[i] += dp[i-1]+2
                        if i-2-dp[i-1] >= 0:
                            dp[i] += dp[i-2-dp[i-1]]
        mmax = 0
        for i in range(len(dp)):
            mmax = max(mmax,dp[i])
        return mmax
```



### [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)(medium, 二维dp)

给定一个只包含三种字符的字符串：`（ `，`）` 和 `*`，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

1. 任何左括号 `(` 必须有相应的右括号 `)`。
2. 任何右括号 `)` 必须有相应的左括号 `(` 。
3. 左括号 `(` 必须在对应的右括号之前 `)`。
4. `*` 可以被视为单个右括号 `)` ，或单个左括号 `(` ，或一个空字符串。
5. 一个空字符串也被视为有效字符串。

**示例 1:**

```
输入: "()"
输出: True
```

**示例 2:**

```
输入: "(*)"
输出: True
```



解法：

二维dp。定义`dp[i][j]`表示字符串 s **从下标 i 到 j 的子串是否是有效的括号串**。

- 如果 s[i]和 s[j] 分别为左括号和右括号，或者为`*`，则当 `dp[i+1][j-1] == True` 时，`dp[i][j] = True`，此时 s[i]和 s[j] 可以分别看成左括号和右括号；
- 如果存在 i<=k<j 使得	`dp[i][k], dp[k+1][j]`都为true，则 `dp[i][j]`也为True，因为两个有效的括号子串**拼接**之后的串也为有效的括号字符串。

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [[False]*n for _ in range(n)]
        for i in range(n):
            if s[i] == "*":
                dp[i][i] = True
        for i in range(n-1,-1,-1): ###i从后往前
            for j in range(0,n): ##j 从前往后
                if i > j:  ##只考虑i<=j的情况
                    continue
                if s[i] in "(*" and s[j] in ")*": ##一种可以为True的方法
                    if i+1 < n and j-1 >= 0 and dp[i+1][j-1]: ##必定之前已经赋值过
                        dp[i][j] = True
                    if i == j-1: ###"()"
                        dp[i][j] = True
                for k in range(i,j): ##第二种可以为True的方法
                    if dp[i][k] and dp[k+1][j]:
                        dp[i][j] = True
        return dp[0][n-1]
```

- 总结：

当i需要访问i+1时，i应该从后往前遍历；j需要访问j-1时，j应该从前往后遍历。为了使我们只访问i<j的情况，可以在循环体中增加：`if i>j: continue`. 