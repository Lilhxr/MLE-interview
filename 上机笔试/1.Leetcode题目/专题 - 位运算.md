# 专题 - 位运算

#### 统计二进制数中1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数。

解法：

最简单的方法就是每一位都用位运算（通过mask）判断是否为1，只需要统计32次。复杂度O(n), n为位数。当然这里n = 32，所以可以理解为O(1).

```python
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        for i in range(32):
            mask = 1 << i
            digit = (n & mask) >> i
            cnt += digit
        return cnt
```

**进阶：**O(logn)方法。

观察这个运算：**n & (n−1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。**所以，我们只需要让 n 不停的 赋值为n & (n-1), 直到n为0.

```python
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n = n & (n-1)
            cnt += 1
        return cnt
```



## IP地址转换

##### **输入描述:**

```
输入 
1 输入IP地址
2 输入10进制型的IP地址
```

##### **输出描述:**

```
输出
1 输出转换成10进制的IP地址
2 输出转换后的IP地址
```

示例1

###### 输入

```
10.0.3.193
167969729
```

###### 输出

```
167773121
10.3.3.193
```

代码：

```python
def ip2num(string):
    string_list = string.split(".")
    ans = 0
    ans += int(string_list[0]) << 24
    ans += int(string_list[1]) << 16
    ans += int(string_list[2]) << 8
    ans += int(string_list[3])
    return ans

def num2ip(num):
    mask = 2 ** 8 - 1
    ip1 = num & mask
    ip2 = (num & (mask << 8)) >> 8
    ip3 = (num & (mask << 16)) >> 16
    ip4 = (num & (mask << 24)) >> 24
    ans = str(ip4)+"."+str(ip3)+"."+str(ip2)+"."+str(ip1)
    return ans
while True:
    try:
        inp = input()
        print(ip2num(inp))
        inp2 = input()
        print(num2ip(int(inp2)))
    except:
        break
```

易错点是要注意位运算的优先级，该写括号的地方一定要写好括号。例如：

`ip2 = (num & (mask << 8)) >> 8` 如果写成 `ip2 = num & (mask << 8) >> 8`就是错误的！