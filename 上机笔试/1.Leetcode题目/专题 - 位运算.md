# 专题 - 位运算

#### 统计二进制数中1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数。

解法：

最简单的方法就是每一位都用位运算（通过mask）判断是否为1，只需要统计32次。复杂度O(n), n为位数。当然这里n = 32，所以可以理解为O(1).

```python
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        for i in range(32):
            mask = 1 << i
            digit = (n & mask) >> i
            cnt += digit
        return cnt
```

**进阶：**O(logn)方法。

观察这个运算：**n & (n−1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。**所以，我们只需要让 n 不停的 赋值为n & (n-1), 直到n为0.

```python
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n = n & (n-1)
            cnt += 1
        return cnt
```



## IP地址转换

##### **输入描述:**

```
输入 
1 输入IP地址
2 输入10进制型的IP地址
```

##### **输出描述:**

```
输出
1 输出转换成10进制的IP地址
2 输出转换后的IP地址
```

示例1

###### 输入

```
10.0.3.193
167969729
```

###### 输出

```
167773121
10.3.3.193
```

代码：

```python
def ip2num(string):
    string_list = string.split(".")
    ans = 0
    ans += int(string_list[0]) << 24
    ans += int(string_list[1]) << 16
    ans += int(string_list[2]) << 8
    ans += int(string_list[3])
    return ans

def num2ip(num):
    mask = 2 ** 8 - 1
    ip1 = num & mask
    ip2 = (num & (mask << 8)) >> 8
    ip3 = (num & (mask << 16)) >> 16
    ip4 = (num & (mask << 24)) >> 24
    ans = str(ip4)+"."+str(ip3)+"."+str(ip2)+"."+str(ip1)
    return ans
while True:
    try:
        inp = input()
        print(ip2num(inp))
        inp2 = input()
        print(num2ip(int(inp2)))
    except:
        break
```

易错点是要注意位运算的优先级，该写括号的地方一定要写好括号。例如：

`ip2 = (num & (mask << 8)) >> 8` 如果写成 `ip2 = num & (mask << 8) >> 8`就是错误的！



#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

难度简单301

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

 

**示例:**

```
输入: a = 1, b = 1
输出: 2
```

题解：两个数的**异或**值就是**不带进位的加法**；两个数的且 就是进位。将二者相加就可以。

```python
class Solution {
public:
    int add(int a, int b) {
        if(b == 0) return a;
        if (a==0) return b;
        return add(a^b, (unsigned int)(a&b) << 1);
    }
};
```

这里要注意的一点是，c++中不支持负数的位移，所以要先转换成(unsigned int). 



----

## 负数补码表示

7的二进制是 0111，那么-7的二进制是多少呢？在计算机中，负数以其正值的**补码**形式表达。

- 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。比如 `00000000 00000000 00000000 00000111` 是 7的 原码。
- 反码：将二进制数**按位取反**，所得的新二进制数称为原二进制数的反码。
  比如：将00000000 00000000 00000000 00000111每一位取反，得11111111 11111111 11111111 11111000。
- 补码：反码加1称为补码。
  补码为：11111111 11111111 11111111 11111000 + 1 = 11111111 11111111 11111111 11111001

所以，-7 在计算机中表达为：11111111 11111111 11111111 11111001

反码转为原码：减1取反。