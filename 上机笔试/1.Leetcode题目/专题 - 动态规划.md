# 专题 - 动态规划

##### 152. 乘积最大子数组

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

```
示例 1:

输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

解法：dp数组存储**以每个位置结尾的**最大乘积、最小乘积。

```python
class Solution:
    def maxProduct(self, nums):
        n = len(nums)
        max_list = [0]*n
        min_list = [0]*n
        max_list[0] = nums[0]
        min_list[0] = nums[0]
        mmax = nums[0]
        for i in range(1,len(nums)):
            if nums[i] >=0:
                max_list[i] = max(max_list[i-1]*nums[i],nums[i]) ##是跟前面的一起乘，还是把前面都扔了？
                min_list[i] = min(min_list[i-1]*nums[i],nums[i])
                mmax = max(mmax,max_list[i])
            else: ## < 0:
                max_list[i] = max(min_list[i-1]*nums[i],nums[i])
                min_list[i] = min(max_list[i-1]*nums[i],nums[i])
                mmax = max(mmax,max_list[i])
        return mmax
```



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/) （背包问题）

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

题解：

`dp[i][j]`表示前i个coins（i从1开始取）能表示出总金额j的总方式。那么，递推公式怎么求呢？有两种方式：一是前i-1个coins就能够表示出金额j；二是我们必须需要coins[i]才能表示出金额j，那么需要1~k个coins[i].

```python
class Solution:
    def change(self, amount: int, coins) -> int:
        n = len(coins)
        dp = [[0]*(amount+1) for _ in range(n+1)]
        for i in range(n+1):
            dp[i][0] = 1 ##表示出金额0有一种方式
            
        for i in range(1,n+1):
            for j in range(1,amount+1):
                dp[i][j] = dp[i-1][j] ##不需要coins[i-1]
                times = j // coins[i-1]
                for time in range(1,times+1): ##必须需要coins[i-1]
                    dp[i][j] += dp[i-1][j-time*coins[i-1]]
                
        return dp[n][amount]
```

