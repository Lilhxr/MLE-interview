# 专题 - 动态规划

##### 152. 乘积最大子数组

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

```
示例 1:

输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

解法：dp数组存储**以每个位置结尾的**最大乘积、最小乘积。

```python
class Solution:
    def maxProduct(self, nums):
        n = len(nums)
        max_list = [0]*n
        min_list = [0]*n
        max_list[0] = nums[0]
        min_list[0] = nums[0]
        mmax = nums[0]
        for i in range(1,len(nums)):
            if nums[i] >=0:
                max_list[i] = max(max_list[i-1]*nums[i],nums[i]) ##是跟前面的一起乘，还是把前面都扔了？
                min_list[i] = min(min_list[i-1]*nums[i],nums[i])
                mmax = max(mmax,max_list[i])
            else: ## < 0:
                max_list[i] = max(min_list[i-1]*nums[i],nums[i])
                min_list[i] = min(max_list[i-1]*nums[i],nums[i])
                mmax = max(mmax,max_list[i])
        return mmax
```



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/) （背包问题）

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

题解：

`dp[i][j]`表示前i个coins（i从1开始取）能表示出总金额j的总方式。那么，递推公式怎么求呢？有两种方式：一是前i-1个coins就能够表示出金额j；二是我们必须需要coins[i]才能表示出金额j，那么需要1~k个coins[i].

```python
class Solution:
    def change(self, amount: int, coins) -> int:
        n = len(coins)
        dp = [[0]*(amount+1) for _ in range(n+1)]
        for i in range(n+1):
            dp[i][0] = 1 ##表示出金额0有一种方式
            
        for i in range(1,n+1):
            for j in range(1,amount+1):
                dp[i][j] = dp[i-1][j] ##不需要coins[i-1]
                times = j // coins[i-1]
                for time in range(1,times+1): ##必须需要coins[i-1]
                    dp[i][j] += dp[i-1][j-time*coins[i-1]]
                
        return dp[n][amount]
```



#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) (背包问题)

难度中等1262

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

题解：硬币问题一样，都是寻找nums中和为target的子数组。

```python
class Solution:
    def canPartition(self, nums) -> bool:
        tot = 0
        for i in range(len(nums)):
            tot += nums[i]
        if tot % 2:
            return False

        target = tot // 2
        print(target, "target")

        n = len(nums)
        dp = [[False]*(target+1) for _ in range(n+1)]
        for i in range(n+1): ##易错！任何位置i之前都可以使之和为0.
            dp[i][0] = True
        for i in range(1,n+1):
            for j in range(1,target+1):
                if dp[i-1][j]: ##i-1之前就已经可以和为j了
                    dp[i][j] = True
                if j-nums[i-1] >= 0:
                    dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]]
        return dp[n][target]
        
```





#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)（easy）

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

**示例1:**

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**解法：**

dp数组的每一位，记录**以这一位为结尾的**最大子数组和。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        dp = [0]*len(nums)
        mmax = nums[0]
        dp[0] = nums[0]
        for i in range(1,len(nums)):
            dp[i] = max(dp[i-1]+nums[i],nums[i]) ##必须以i为结尾。那么就需要考虑包括/不包括前面的部分。反正nums[i]都是一定要加上的。
            mmax = max(mmax,dp[i])
        return mmax
```





#### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

难度中等1371

给你一个整数 `n` ，返回 *和为 n 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

题解：本题的思路很简单，就是用dp数组记录和为i的完全平方数最小的数量，然后每次找到最小的dp[i-j*j]。但是从本题可以看到很多dp的易错点，所以还是写一下！

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [1] * (n + 1)
        dp[0] = 0
        for i in range(2, n + 1):
            mmin = 1000000 ##还是写一个变量来保存最小值为好！！
            for j in range(1, int(math.sqrt(i)) + 1): ##注意，我们应该能够取到sqrt(i), 所以这里要+1
                if i - j * j >= 0:
                    mmin = min(mmin, dp[i - j * j])
            dp[i] = mmin + 1 ##更新
        return dp[-1]
```

