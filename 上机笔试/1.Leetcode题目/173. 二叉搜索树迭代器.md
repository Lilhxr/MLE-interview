#### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

难度中等584

实现一个二叉搜索树迭代器类

```
BSTIterator
```

 

，表示一个按中序遍历二叉搜索树（BST）的迭代器：

- `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
- `boolean hasNext()` 如果向指针右侧遍历存在数字，则返回 `true` ；否则返回 `false` 。
- `int next()`将指针向右移动，然后返回指针处的数字。

注意，指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。

你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 的中序遍历中至少存在一个下一个数字。

 

**示例：**



```
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
```



题解：用中序遍历的迭代解法：

```python
class Solution:
    def inorderTraversal(self, root):
        stack = []  ##显式的用栈模拟
        ans = []
        while(True): ##反复地
            while(root):  ##藤蔓入栈
                stack.append(root)
                root = root.left
            if len(stack) == 0: ##直至所有节点处理完毕
                break
            root = stack.pop()  ##x的左子树或为空，或已经遍历，故可以...
            ans.append(root.val) ##...立即访问之
            root = root.right ##再转向右子树
        return ans
```

所以，本题的next()函数则对应迭代解法中的`ans.append(root.val)`

```
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.root = root
        self.now = None
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self) -> int:
        if len(self.stack) == 0:
            return -1
        root = self.stack.pop()
        ans = root.val ##访问
        root = root.right
        while root:
            self.stack.append(root)
            root = root.left
        return ans

    def hasNext(self) -> bool:
        return len(self.stack)!=0
```

