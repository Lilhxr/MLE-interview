#### [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

难度中等699

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)

```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

题解：

我们在中序遍历的时候，**顺便**记录下来哪一块位置的节点是**有问题的节点**，把两个节点都找出来之后交换二者的值即可。

题目给出的例子不是很有代表性，我们来自己写一个有代表性的例子：

![img](https://pic2.zhimg.com/80/v2-8eb4924c1b014f3fb9e8fcb5be4d3b27_1440w.png)

```python

class Solution:
    prev = None
    error1 = None ##第一个有问题的节点，为在前面的大数
    error2 = None ##第二个有问题的节点，在后面的小数
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        def inorder(root): ##中序遍历
            if root == None: ##返回条件
                return
            inorder(root.left) ##遍历左子树...
            ###开始处理当前的值###
            if not self.prev: 
                self.prev = root
            else:
                if self.prev.val > root.val and self.error1 == None: ##前面的大数
                    self.error1 = self.prev
                if self.prev.val > root.val: ##后面的小数
                    self.error2 = root
            self.prev = root
            ####################
            inorder(root.right) ##遍历右子树
        inorder(root)
        #### 交换二者的值 ####
        tmp = self.error1.val
        self.error1.val = self.error2.val
        self.error2.val = tmp
```

