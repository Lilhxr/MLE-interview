#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)



题解：

不要去想迭代解法，因为迭代解法要考虑非常多的边界条件，还要记录predecessor和successor。所以，只需考虑递归解法。

那么，我们要想清楚递归解法的返回值是什么。在这里，递归解法输入一个根root，然后返回删除掉它之后的根root'. 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:

    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]: ##递归地删除，返回删除后的节点root
        if not root:
            return None
        if root.val == key: ###命中，删除之
            if not root.left and not root.right: ##叶子节点，直接删除掉
                return None 
            elif not root.right: ##直接用左节点来替换
                return root.left
            elif not root.left:
                return root.right
            else: ##右子树的第一个访问节点的左孩子变成根的左节点
                left_tree = root.left
                right_node = root.right
                while right_node.left:
                    right_node = right_node.left
                right_node.left = left_tree
                return root.right
        elif root.val < key:
            root.right = self.deleteNode(root.right,key) ##删除右子树
            return root
        else:
            root.left = self.deleteNode(root.left,key) ##删除左子树
            return root
```

当要删除的节点左右孩子都有的时候，删除它稍微一些困难。例如在下面这个例子中，删除节点4.

想要删除节点4，我们需要让6替代4的位置，并且把节点4的左孩子 -- 节点2移到节点6所在子树的最小值（节点5）的左子树. 如何找到这个最小值呢？其实就是一直向左孩子找。

![20220401_105200504_iOS.jpg](https://pic.leetcode-cn.com/1648814780-aBpncQ-20220401_105200504_iOS.jpg)