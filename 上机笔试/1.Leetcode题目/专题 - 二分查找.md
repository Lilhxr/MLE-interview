# 专题 - 二分查找



### 基础：

给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被**按顺序插入的位置**。

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int end = nums.size()-1;
        int begin = 0;
        while(begin <= end){
            int middle = (begin+end)/2;
            if(nums[middle] == target) return middle;
            if(nums[middle] < target){
                begin = middle + 1;
            }
            else if (nums[middle] > target){
                end = middle-1;
            }
        }
        return begin;
    }
};
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

思路：其实，只需对二分查找进行一点修改，让它在找到target之后继续向左/向右移动。

```python
class Solution:
    def searchRange(self, nums, target: int):
        n = len(nums)
        if n == 0:
            return [-1,-1]
        left = self.binary_search_min(nums,target,0,n-1)
        right = self.binary_search_max(nums,target,0,n-1)
        if left >= n or nums[left] != target:
            return [-1,-1]
        ans = [self.binary_search_min(nums,target,0,n-1),self.binary_search_max(nums,target,0,n-1)-1]
        return ans


    def binary_search_max(self,nums,target,begin,end):
        while(begin <= end):
            middle = (begin+end)//2
            if nums[middle] <= target: ## 等于的时候还要继续后移
                begin = middle+1
            if nums[middle] > target:
                end = middle-1
        return begin

    def binary_search_min(self,nums,target,begin,end):
        while(begin <= end):
            middle = (begin+end)//2
            if nums[middle] < target:
                begin = middle+1
            if nums[middle] >= target: ##等于的时候还要继续前移
                end = middle-1
        return begin
```





#### 33. 搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

```python
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

将情况分为两类：middle处在左侧上升区、middle处在右侧上升区。

![fig1](https://assets.leetcode-cn.com/solution-static/33/33_fig1.png)

如果middle处在左侧上升区(`nums[middle] >= nums[0]`)，而target也处在左侧上升区(`target >= nums[0]`)，且比nums[middle]小(`target < nums[middle]`)，那么一定向左查找(`end = middle - 1`)；否则向右查找(`begin = middle+1`)。

如果middle处在右侧上升区，而target也处在右侧上升区(`target <= nums[n-1]`)，且比nums[middle]大(`target > nums[middle]`)，那么一定向右查找(`begin = middle+1`)，否则向左查找(`end = middle - 1`)。

一旦把这个关系捋清楚，就十分简单了。**【对于较为复杂逻辑的题目，应该先写伪代码理清思路再动笔写！】**不然很容易陷入混乱。

```python
class Solution:
    def search(self, nums, target: int) -> int:
        begin = 0
        end = len(nums)-1
        while(begin <= end):
            middle = int((begin+end)/2)
            if nums[middle] == target:
                return middle

            if nums[middle] >= nums[0]: ##middle 处在左侧上升区
                if target >= nums[0] and target < nums[middle]:  ##target必在左侧上升区
                    end = middle-1
                else:      ## target必在右侧上升区
                    begin = middle + 1
                    
            else:  ##middle 处在右侧上升区
                if target <= nums[len(nums)-1] and target > nums[middle]:    ##target在左侧上升区
                    begin = middle + 1
                else:          ##target在右侧上升区
                    end = middle - 1
```

相似题目：如果有**重复数字**怎么办呢？其实，重复数字只会影响我们判断左侧上升区还是右侧上升区，所以，提前把**尾部**的重复数字**去掉**。

相似题目：寻找旋转排序数组中的最小值。同样也是分为“左侧上升区”、“右侧下降区”来进行判断。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        begin = 0
        end = len(nums)-1
        while(begin <= end):
            middle = (begin + end) // 2
            if nums[middle] >= nums[0]: ##左侧上升区
                begin = middle + 1
            else: ##右侧下降区
                end = middle - 1
        if begin >= len(nums):
            return nums[0]
        return nums[begin]
```

#### 162. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

```python
class Solution:
    def findPeakElement(self, nums) -> int:
       ####左边右边都是-inf(物理),当然也可以写一个get(idx)函数来虚拟的得到-inf
        neg_inf = -2**32
        nums.insert(0,neg_inf)
        nums.append(neg_inf)
        
        begin = 0
        end = len(nums)-1
        while(begin <= end):
            middle = (begin+end) // 2
            if nums[middle] > nums[middle-1] and nums[middle] > nums[middle+1]: ##已经是峰值
                return middle-1
            if nums[middle] > nums[middle-1]:  ##在左侧上升区
                begin = middle+1
            else:  #右侧下降区
                end = middle-1
        return begin
```



##### 540. 有序数组的单一元素

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

```
示例 1:
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

思路：分middle是奇数还是偶数的情况来讨论。为了避免0和n-1处的特殊判断，不妨在前后都做padding。这也是一个非常实用的技巧。

当middle是偶数时，如果相等的是左边，那么就继续向左；相等的是右边，就继续向右。

当middle是奇数时，正好相反。

如果左边右边都不相等，就是答案！

```python
class Solution:
    def singleNonDuplicate(self, nums: list) -> int:
        nums.insert(0,nums[0]-1)
        nums.insert(0,nums[1]-1)
        nums.append(nums[-1]+1)
        nums.append(nums[-2]+1)

        begin = 0
        end = len(nums)-1
        while begin <= end:
            middle = (begin+end) // 2
            if nums[middle-1] != nums[middle] and nums[middle]!=nums[middle+1]:
                return nums[middle]
            if nums[middle-1] == nums[middle]:
                left = True
            if nums[middle+1] == nums[middle]:
                left = False
            if middle % 2 == 0:
                if left:
                    end = middle-1
                else:
                    begin = middle+1
            else:
                if left:
                    begin = middle+1
                else:
                    end = middle-1
```



----

## 二分答案

二分法不一定是对于一个排序的数组进行查找，还有一大类方法是“二分答案”，即，我们直到答案一定是[begin,end]范围的**整数**，然后我们就可以二分[begin,end]这个范围，对于middle，就检验它是否满足条件，如果满足条件就立刻返回；如果不满足条件，判断应该向左查找还是向右查找。

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)(medium)

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。



**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

题解：

由于我们知道答案一定属于[1,n], 那么就可以**二分答案**了。

对于一个middle，我们记录middle在nums中出现的次数，以及比middle小的数在nums中出现的次数。如果middle的确出现过1次以上，则立刻返回；如果比middle小的数出现次数 >= middle,就说明重复的数一定出现在[1,middle-1]; 否则，重复的数一定出现在[middle+1,n].

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        begin = 1
        end = len(nums)
        while begin <= end:
            middle = (begin+end) // 2
            middle_cnt = 0 ###middle 出现的次数
            less_than_middle_cnt = 0 ##比middle小的数出现的次数
            for i in range(len(nums)):
                if nums[i] == middle:
                    middle_cnt += 1
                if nums[i] < middle:
                    less_than_middle_cnt += 1
            if middle_cnt >= 2:
                return middle
            elif less_than_middle_cnt >= middle:
                end = middle-1
            else:
                begin = middle+1
```



#### 木头切割问题

给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。

输入两行，第一行n, k，第二行为数组序列。输出最大值。

> 输入
> 5 5
> 4 7 2 10 5
> 输出
> 4
> 解释：如图，最多可以把它分成5段长度为4的木头
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVHVR60EJHyZEZAdt5KkTSSvpjP30ZWe9WxlFFHibiaPchmjVcVpkkCkVqUNicm9NReAvCbKC0vdy6sZg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

思路：暴力法就是枚举1~max(arr)的每种长度可能，判断这堆木头能否截取出至少k个相同长度的木块。这样，就可以很简单的用二分方法来优化，搜索区间就是[1,max(arr)]

```python
def function(nums,k):
    left = 1
    right = max(nums)
    def feasible(nums,k,target):
        cnt = 0
        for i in range(len(nums)):
            cnt += nums[i] // target
        return cnt >= k

    while left <= right:
        middle = (left+right) // 2
        if feasible(nums,k,middle):
            left = middle + 1
        else:
            right = middle - 1
    return left-1
```

注意最后要返回left-1而不是left



#### [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

难度中等284

珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。

珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。



**示例 1：**

```
输入：piles = [3,6,7,11], h = 8
输出：4
```

题解：二分答案，从最小的速度(1)到最大速度(`max(piles)`)进行二分。

```python
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        begin = 1
        end = max(piles) ##最大的可能速度
        while begin <= end:
            middle = (begin+end) // 2
            cnt = 0 ##记录吃掉所有香蕉的时间
            for i in range(len(piles)):
                if piles[i] % middle == 0:
                    cnt += piles[i] // middle
                else:
                    cnt += piles[i] // middle+1
            if cnt > h: ##时间过长
                begin = middle+1 ##只能去寻找更大的速度
            else: ##否则
                end = middle-1 ##可以尝试减小速度
        return begin
```

#### [29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

难度中等891

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8` 以及 `truncate(-2.7335) = -2`

 

**示例 1:**

```
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
```

题解：

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        signal = 1
        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):
            signal = -1 ##记录符号
        if dividend == 0:
            return 0
        dividend = abs(dividend)
        divisor = abs(divisor)
        if divisor == 1: ##一些特判
            return min(dividend*signal,2**31-1)

        begin = 1
        end = dividend ##二分区间
        while begin <= end: 
            middle = (begin+end) // 2
            if divisor*middle == dividend: ##正好相等
                return signal*middle
            if divisor*(middle+1) == dividend:##正好相等
                return signal*(middle+1)
            if divisor*(middle) < dividend and divisor*(middle+1) > dividend: ##floor，已经找到了答案
                return signal*middle
            if divisor*middle > dividend:
                end = middle-1
            else:
                begin = middle+1
```

【易错点1】需要特判`if divisor*(middle+1) == dividend`

【易错点2】最后的区间改变必须是if-else形式，否则可能会导致死循环。例如不能够写

```
            if divisor*middle > dividend:
                end = middle-1
            if divisor*(middle+1) < dividend:
                begin = middle+1
```

