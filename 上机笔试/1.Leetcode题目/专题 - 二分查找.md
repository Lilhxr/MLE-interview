# 专题 - 二分查找



### 基础：

给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被**按顺序插入的位置**。

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int end = nums.size()-1;
        int begin = 0;
        while(begin <= end){
            int middle = (begin+end)/2;
            if(nums[middle] == target) return middle;
            if(nums[middle] < target){
                begin = middle + 1;
            }
            else if (nums[middle] > target){
                end = middle-1;
            }
        }
        return begin;
    }
};
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

思路：其实，只需对二分查找进行一点修改，让它在找到target之后继续向左/向右移动。

```python
class Solution:
    def searchRange(self, nums, target: int):
        n = len(nums)
        if n == 0:
            return [-1,-1]
        left = self.binary_search_min(nums,target,0,n-1)
        right = self.binary_search_max(nums,target,0,n-1)
        if left >= n or nums[left] != target:
            return [-1,-1]
        ans = [self.binary_search_min(nums,target,0,n-1),self.binary_search_max(nums,target,0,n-1)-1]
        return ans


    def binary_search_max(self,nums,target,begin,end):
        while(begin <= end):
            middle = (begin+end)//2
            if nums[middle] <= target: ## 等于的时候还要继续后移
                begin = middle+1
            if nums[middle] > target:
                end = middle-1
        return begin

    def binary_search_min(self,nums,target,begin,end):
        while(begin <= end):
            middle = (begin+end)//2
            if nums[middle] < target:
                begin = middle+1
            if nums[middle] >= target: ##等于的时候还要继续前移
                end = middle-1
        return begin
```





#### 33. 搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

```python
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

将情况分为两类：middle处在左侧上升区、middle处在右侧上升区。

![fig1](https://assets.leetcode-cn.com/solution-static/33/33_fig1.png)

如果middle处在左侧上升区(`nums[middle] >= nums[0]`)，而target也处在左侧上升区(`target >= nums[0]`)，且比nums[middle]小(`target < nums[middle]`)，那么一定向左查找(`end = middle - 1`)；否则向右查找(`begin = middle+1`)。

如果middle处在右侧上升区，而target也处在右侧上升区(`target <= nums[n-1]`)，且比nums[middle]大(`target > nums[middle]`)，那么一定向右查找(`begin = middle+1`)，否则向左查找(`end = middle - 1`)。

一旦把这个关系捋清楚，就十分简单了。**【对于较为复杂逻辑的题目，应该先写伪代码理清思路再动笔写！】**不然很容易陷入混乱。

```python
class Solution:
    def search(self, nums, target: int) -> int:
        begin = 0
        end = len(nums)-1
        while(begin <= end):
            middle = int((begin+end)/2)
            if nums[middle] == target:
                return middle

            if nums[middle] >= nums[0]: ##middle 处在左侧上升区
                if target >= nums[0] and target < nums[middle]:  ##target必在左侧上升区
                    end = middle-1
                else:      ## target必在右侧上升区
                    begin = middle + 1
                    
            else:  ##middle 处在右侧上升区
                if target <= nums[len(nums)-1] and target > nums[middle]:    ##target在左侧上升区
                    begin = middle + 1
                else:          ##target在右侧上升区
                    end = middle - 1
```

相似题目：如果有**重复数字**怎么办呢？其实，重复数字只会影响我们判断左侧上升区还是右侧上升区，所以，提前把首尾的重复数字**都去掉**。

相似题目：寻找旋转排序数组中的最小值。同样也是分为“左侧上升区”、“右侧下降区”来进行判断。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        begin = 0
        end = len(nums)-1
        while(begin <= end):
            middle = (begin + end) // 2
            if nums[middle] >= nums[0]: ##左侧上升区
                begin = middle + 1
            else: ##右侧下降区
                end = middle - 1
        if begin >= len(nums):
            return nums[0]
        return nums[begin]
```

#### 162. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

```python
class Solution:
    def findPeakElement(self, nums) -> int:
       ####左边右边都是-inf(物理),当然也可以写一个get(idx)函数来虚拟的得到-inf
        neg_inf = -2**32
        nums.insert(0,neg_inf)
        nums.append(neg_inf)
        
        begin = 0
        end = len(nums)-1
        while(begin <= end):
            middle = (begin+end) // 2
            if nums[middle] > nums[middle-1] and nums[middle] > nums[middle+1]: ##已经是峰值
                return middle-1
            if nums[middle] > nums[middle-1]:  ##在左侧上升区
                begin = middle+1
            else:  #右侧下降区
                end = middle-1
        return begin
```



##### 540. 有序数组的单一元素

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

```
示例 1:
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

思路：分middle是奇数还是偶数的情况来讨论。为了避免0和n-1处的特殊判断，不妨在前后都做padding。这也是一个非常实用的技巧。

当middle是偶数时，如果相等的是左边，那么就继续向左；相等的是右边，就继续向右。

当middle是奇数时，正好相反。

如果左边右边都不相等，就是答案！

```python
class Solution:
    def singleNonDuplicate(self, nums: list) -> int:
        nums.insert(0,nums[0]-1)
        nums.insert(0,nums[1]-1)
        nums.append(nums[-1]+1)
        nums.append(nums[-2]+1)

        begin = 0
        end = len(nums)-1
        while begin <= end:
            middle = (begin+end) // 2
            if nums[middle-1] != nums[middle] and nums[middle]!=nums[middle+1]:
                return nums[middle]
            if nums[middle-1] == nums[middle]:
                left = True
            if nums[middle+1] == nums[middle]:
                left = False
            if middle % 2 == 0:
                if left:
                    end = middle-1
                else:
                    begin = middle+1
            else:
                if left:
                    begin = middle+1
                else:
                    end = middle-1
```



#### 木头切割问题

给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。

输入两行，第一行n, k，第二行为数组序列。输出最大值。

> 输入
> 5 5
> 4 7 2 10 5
> 输出
> 4
> 解释：如图，最多可以把它分成5段长度为4的木头
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVHVR60EJHyZEZAdt5KkTSSvpjP30ZWe9WxlFFHibiaPchmjVcVpkkCkVqUNicm9NReAvCbKC0vdy6sZg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

思路：暴力法就是枚举1~max(arr)的每种长度可能，判断这堆木头能否截取出至少k个相同长度的木块。这样，就可以很简单的用二分方法来优化，搜索区间就是[1,max(arr)]

```python
def function(nums,k):
    left = 1
    right = max(nums)
    def feasible(nums,k,target):
        cnt = 0
        for i in range(len(nums)):
            cnt += nums[i] // target
        return cnt >= k

    while left <= right:
        middle = (left+right) // 2
        if feasible(nums,k,middle):
            left = middle + 1
        else:
            right = middle - 1
    return left-1
```

注意最后要返回left-1而不是left