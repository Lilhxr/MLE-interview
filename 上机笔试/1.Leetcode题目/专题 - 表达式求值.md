# 专题 - 表达式求值

对于中缀表达式求值问题，我们首先定义运算符栈和操作数栈，其中运算符栈要先放进去一个"$"哨兵符号。

然后，把原来的表达式处理一下，在后面加一个尾哨兵"$".



我们再来定义栈顶运算符与新来运算符的优先级：

![img](https://pic2.zhimg.com/80/v2-9a36fadf37ccb1f151f0ff9ac7af52d5_1440w.jpeg)

当栈顶优先级比新来的运算符优先级还高，我们就要开始执行栈顶的这个运算符了，然后把算出的结果push进操作数栈；

当栈顶的优先级比新来的运算符优先级低，那么就只好忍辱负重，静待时机（新运算符进栈，“后来居上”）

当栈顶优先级和新来的运算符优先级一样，那么只有两种情况：一是栈顶为"(",新来的运算符为")", 那么我们需要脱掉左括号，并且指针向右移动，开始读后面的字符；二是栈顶为最开始入栈的标识符"$",新来的运算符为"\$",这两个就匹配上了，说明已经完成了运算。

![img](https://pic2.zhimg.com/80/v2-141ca7bcea574474fd63da3c5f6b17e6_1440w.jpeg)



#### [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/) (hard)

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。

示例 1：

```
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
```

- '-' 可以用作一元运算(即 "-1" 和 `"-(2 + 3)"` 是有效的)

```python
class Solution:
    def calculate(self, s: str) -> int:
        s = s.replace(" ","")
        #################解决负号问题 #####################
        if s[0] == "-" and s[1]!="(":  ##解决形如"-1223+3"的问题
            ptr = 1
            while s[ptr] in "1234567890":
                ptr+=1
            s = "(0"+s[:ptr]+")"+s[ptr:]
        if s[0] == "-" and s[1] == "(": ##解决形如"-(3+4)"的问题
            s = "0"+s
        for i in range(len(s)-1): ##解决形如"0+(-2)*3"的问题
            if s[i] == "(" and s[i+1] == "-": 
                s = s[:i+1]+"0"+s[i+1:]
		####################################################
        s+="$" ##末尾加入哨兵

        oper_dic = {"+":0,"-":1,"*":2,"/":3,"(":4,")":5,'$':6}
        prior = [['>','>','<','<','<','>','>'],['>','>','<','<','<','>','>'],['>','>','>','>','<','>','>'],['>','>','>','>','<','>','>'],['<','<','<','<','<','=',' '],[' ',' ',' ',' ',' ',' ',' '],['<','<','<','<','<',' ','=']]
        
        def compare(stack_top,new): ##比较栈顶和现在新来的运算符优先级
            stack_top_idx = oper_dic[stack_top]
            new_idx = oper_dic[new]
            return prior[stack_top_idx][new_idx]
        
        op_stack = ["$"] ##操作符栈，先加入哨兵
        num_stack = [] ##操作数栈
        i = 0
        while i < len(s):
            if s[i] in "1234567890": ##贪婪的读进来数字
                num = 0
                while s[i] in "1234567890":
                    num = num * 10 + int(s[i])
                    i += 1
                num_stack.append(num)
            else: ##来的是个符号
                priority = compare(op_stack[-1],s[i])
                if priority == ">": ##可以执行栈顶操作符了！
                    op = op_stack.pop()
                    num1 = num_stack.pop()
                    num2 = num_stack.pop()
                    if op == "+":
                        num3 = num1 + num2
                    if op == "-":
                        num3 = num2 - num1
                    if op == "*":
                        num3 = num2 * num1
                    if op == "/":
                        num3 = num2 // num1
                    num_stack.append(num3) ##进操作数栈
                if priority == "<": #等待时机
                    op_stack.append(s[i])
                    i += 1
                if priority == "=": #:右括号，或者已经到了结尾，终须了断
                    op_stack.pop() ##脱括号并接收下一个字符
                    i += 1
        return num_stack[0]
```

