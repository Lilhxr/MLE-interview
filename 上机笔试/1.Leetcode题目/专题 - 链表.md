# 链表相关

#### Leetcode 206 反转链表

题目描述：给你单链表的头节点 head，请你反转链表，并返回反转后的链表。

**迭代法和递归法都要会。**

【迭代法】

只需要将每个节点的next指针修改成指向前面即可。所以设置prev和curr, 每次都将curr的next指针指向prev。

```python
ListNode* reverse_list(ListNode* head){ //迭代方法反转单链表
        ListNode* prev = NULL;
        ListNode* curr = head;
        while(curr){
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;//return now是错的！！因为now在循环结束之后一定是null啊
    }
```

【递归法】

![img](https://pic2.zhimg.com/80/v2-28ca629b058e068ce6d7825a1604c420_1440w.png)

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head == None:
            return None
        if head.next == None:
            return head
        reverse_head_next = self.reverseList(head.next)
        head.next.next = head ##这两句是关键
        head.next = None ##否则成环
        return reverse_head_next
```

【易错】

head.next = None，否则会成环

return的结果是new head

【总结】

反转链表之后，head指向的下一个依然是原先的next节点。



#### 92. 反转链表II

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next
class Solution:
    def reverseBetween(self, head, left, right):
        head0 = ListNode(-1) ##dummy head
        head0.next = head
        left_ptr = head0
        right_ptr = head0
        for i in range(left-1):
            left_ptr = left_ptr.next
        for i in range(right):
            right_ptr = right_ptr.next

        reverse_head = left_ptr.next
        left_ptr.next = None
        right_remain = right_ptr.next
        right_ptr.next = None
        
        reverse_head_ = self.reverse_list(reverse_head)
        left_ptr.next = reverse_head_
        
        tmp = reverse_head_
        while(tmp.next):
            tmp = tmp.next
        tmp.next = right_remain
        return head0.next

    def reverse_list(self,head):
        prev = None
        curr = head
        while curr:
            curr_next = curr.next
            curr.next = prev
            prev = curr
            curr = curr_next
        return prev
```

【总结】在链表中，应该善用dummy head。





##### 369. 给单链表加一                                                                                                    

  给定一个用单链表表示的整数，然后把这个整数加一。 

  例如输入{1,2,3}时，对应的输出为{1,2,4}，转换过程如下图所示： 

  ![img](https://uploadfiles.nowcoder.com/images/20211201/423483716_1638339504938/825D037583321641BC5C076ED2614EBA)






题解：

首先，我们需要反转链表；然后，在末尾（也就是反转后的开头）+1。注意只有开头需要+1，所以需要一个变量来判断是不是在开头。如果不是开头，则不需要+1。那么答案保存在哪里呢？我们需要新建一个dummy head，用它来保存结果链表。

```python
class Solution:
    def plusOne(self , head: ListNode) -> ListNode:
        def reverse(head): ##反转链表
            prev = None
            curr = head
            while curr:
                curr_next = curr.next
                curr.next = prev
                prev = curr
                curr = curr_next
            return prev
        head = reverse(head)

        carry = 0
        head0 = ListNode(-1) ##新建一个dummy head保存答案
        tmp0 = head0
        tmp = head ##遍历原先的链表
        begin = True
        
        while tmp:
            if begin: ##只有开始的时候才需要+1
                val = (tmp.val + 1 + carry) % 10
                carry = (tmp.val + 1 + carry ) //10
                tmp0.next = ListNode(val) ##新建节点
                begin = False
            else:
                val = (tmp.val+ carry) % 10
                carry = (tmp.val + carry ) //10
                tmp0.next = ListNode(val)
            tmp0 = tmp0.next
            tmp = tmp.next
        if carry:
            tmp0.next = ListNode(1)
        return reverse(head0.next)
```

【总结】

- 用dummy head来记录节点
- 末尾+1，只有最开始才需要+1，需要用一个变量记录是不是开头。

#### 21. 合并两个有序链表[easy]

直接改变节点之间的连接关系即可。

```python
# Definition for singly-linked list.            
                    
class Solution:                                 
    def mergeTwoLists(self, list1, list2):      
        tmp1 = list1                            
        tmp2 = list2                            
        head = ListNode(-1)  ##dummy head                   
        tmp = head                              
        while(tmp1 and tmp2):                   
            if tmp1.val < tmp2.val:             
                tmp.next = tmp1                 
                tmp1 = tmp1.next                
                tmp = tmp.next                  
            else:                               
                tmp.next = tmp2                 
                tmp2 = tmp2.next                
                tmp = tmp.next                  
        while(tmp1):                            
            tmp.next = tmp1                     
            tmp1 = tmp1.next                    
            tmp = tmp.next                      
        while(tmp2):                            
            tmp.next = tmp2                     
            tmp2 = tmp2.next                    
            tmp = tmp.next                      
        return head.next                           
```



### 23. 合并K个有序链表 [hard]

二分递归+合并两个有序链表

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next
         
class Solution:
    def mergeKLists(self, lists):   ###二分法合并
        n = len(lists)
        if n == 0:
            return None
        if n == 1:    ##不用合并了
            return lists[0]
        return self.DFS(lists,0,n-1)
        
    def DFS(self,lists,begin,end):
        if begin == end:
            return lists[begin]
        if begin > end:
            return []
        middle = int((begin+end)/2)
        leftpart = self.DFS(lists,begin,middle)
        rightpart = self.DFS(lists,middle+1,end)
        return self.mergeTwoLists(leftpart,rightpart)
        
        
        
    def mergeTwoLists(self, list1, list2):  ##合并两个有序链表    
        tmp1 = list1                            
        tmp2 = list2                            
        head = ListNode(-1)  ##dummy head                   
        tmp = head                              
        while(tmp1 and tmp2):                   
            if tmp1.val < tmp2.val:             
                tmp.next = tmp1                 
                tmp1 = tmp1.next                
                tmp = tmp.next                  
            else:                               
                tmp.next = tmp2                 
                tmp2 = tmp2.next                
                tmp = tmp.next                  
        while(tmp1):                            
            tmp.next = tmp1                     
            tmp1 = tmp1.next                    
            tmp = tmp.next                      
        while(tmp2):                            
            tmp.next = tmp2                     
            tmp2 = tmp2.next                    
            tmp = tmp.next                      
        return head.next                           
```



### 25. K个一组翻转链表 [hard]

递归翻转，前翻转前K个，然后再翻转后面的。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next

class Solution:
    def reverseKGroup(self, head, k: int):
        if head == None:
            return None
        tmp = head
        can = True
        for i in range(k-1):
            if tmp.next:
                tmp = tmp.next
            else:
                can = False
                break
        if not can:     ##不够翻转，则直接返回head
            return head
            
        next_head = tmp.next
        tmp.next = None
        head = self.reverse_list(head)
        tmp = head
        while(tmp.next):
            tmp = tmp.next
        tmp.next = self.reverseKGroup(next_head,k)
        return head


    def reverse_list(self,head):  ##翻转链表
        prev = None
        curr = head
        while(curr):
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
```





#### 141. 环形链表 [easy]

判断链表里是否有环。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

就是【快慢指针】，一旦相遇则有环。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for singly-linked list.
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None  
         
         
class Solution:      
    def hasCycle(self, head) -> bool:
        slow = head
        fast = head
        while(slow and fast and fast.next):
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```



【易错点】

- while的条件是`slow and fast and fast.next`, 不要忘记写`fast`,否则如果fast = NULL，会报错

#### 142. 环形链表的入口节点

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

在Z处相遇，则快指针走了a+(b+c)*n+b; 慢指针走了a+b. 由于快指针速度是慢指针的两倍，所以有：

2a+2b = a+(b+c)*n+b. 那么，有：a+b = (b+c)\*n ,即：a = (b+c)\*n-b

因此让两个指针分别**从起始点X和相遇点Z以相同速度前进**，两个指针再次相遇的位置即为环的入口节点Y。

**【更简单的方法】直接用哈希表**

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow = head
        fast = head
        while slow and fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast: ##相遇
                x = slow ##从相遇点开始
                y = head ##从头开始
                while True:
                    if x==y :
                        return x
                    x = x.next
                    y = y.next
        return None
```



#### 160. 相交链表

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)



两个指针，如果为Null则指向对方的头，如果两者相交，则必能遇上；如果不相交，则一定能够同时指向NULL。

```python
class Solution:
    def getIntersectionNode(self, headA, headB):
        pA = headA
        pB = headB
        while True:
            if pA == pB: #相交
                return pA
            if pA == None:
                pA = headB
            else: ##注意if-else逻辑
                pA = pA.next
            if pB == None:
                pB = headA
            else:
                pB = pB.next
```



#### 143. 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

![img](https://pic.leetcode-cn.com/1626420320-YUiulT-image.png)



【思路】快慢指针找中点、反转链表、合并两个链表



```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        slow = head
        fast = head.next
        while(slow and fast and fast.next):
            slow = slow.next
            fast = fast.next.next
        right_list = self.reverse_list(slow.next)  ##找到链表的中点
        slow.next = None

        head0 = ListNode(-1) ##【合并两个链表】
        tmp = head0
        ptr1 = head
        ptr2 = right_list

        left = 1
        while(ptr1 and ptr2):
            if left:
                tmp.next = ptr1
                tmp = tmp.next
                ptr1 = ptr1.next
                left = 0
            else:
                tmp.next = ptr2
                tmp = tmp.next
                ptr2 = ptr2.next
                left = 1
        if ptr1:
            tmp.next = ptr1
        if ptr2:
            tmp.next = ptr2
        return head0.next
                

    def reverse_list(self,head): #反转链表
        prev = None
        curr = head
        while(curr):
            curr_next = curr.next
            curr.next = prev
            prev = curr
            curr = curr_next
        return prev
```

找链表中点的方法：

```python
slow = head
fast = head.next
while(slow and fast and fast.next):
	slow = slow.next
    fast = fast.next.next
```



#### 83. 删除排序链表中的重复元素 [easy]

存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除所有重复的元素，使每个元素**只出现一次** 



思路：使用两个指针i，j，如果i和j的元素相等，就一直移动j，直到i和j不等。这时，让i->next指向j，并且i移动到j的位置，继续...

```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        i = head
        j = head
        while(i and j):
            while i and j and j.val == i.val:
                j = j.next
            i.next = j
            i = j
        return head
```

相似题：26.删除排序数组中的重复项

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ptr = 0 ##原地修改的指针
        i = 0; j = 0
        while i < len(nums) and j < len(nums):
            while i < len(nums) and j < len(nums) and nums[i] == nums[j]:
                j += 1
            nums[ptr] = nums[i] ##记录
            ptr += 1
            i = j
        return ptr
```

相似题：1047.删除字符串中相邻的重复项

```
示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

“消消乐”思想，先append，然后不断考察栈顶

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for i in range(len(s)):
            stack.append(s[i])
            while len(stack) >= 2 and stack[-1] == stack[-2]:
                stack.pop(); stack.pop()
        return "".join(stack)
```



#### 82. 删除排序链表中的重复元素II 

题目描述：给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。

例如：给出的链表为1→2→3→3→4→4→5, 返回1→2→5.

思路：

由于要把整个重复出现的元素全部删掉，所以就一定要维护一个i_prev指针，指向左指针的前一个值。我们让最开始的i_prev指向dummy head，而i、j指向head；之后，如果j.val == i.val,就不停的移动右指针，同时记录下来，这里是重复的值，之后要去除之。

```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        head0 = ListNode(-1)
        head0.next = head
        i_prev = head0
        i = head0.next
        j = head0.next
        while i and j:
            dup = False ##记录有没有重复
            cnt = 0
            while i and j and i.val == j.val: ##一直右移，直到第一个不相等的位置
                j = j.next
                cnt += 1
                if cnt >= 2: ##因为一开始i = j,所以两者必定相等
                    dup = True
            if dup: ##有重复
                i_prev.next = j
                i = j
            else: 
                i = j
                i_prev = i_prev.next
        return head0.next
```



#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

难度简单913

给你一个链表的头节点head和一个整数val，请你删除链表中所有满足Node.val == val的节点，并返回新的头节点。

 **示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

题解：

```python
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        
        newhead = ListNode(-1)
        newhead.next = head
        tmp = newhead
        while tmp and tmp.next:
            if tmp.next.val == val: ##需要删除之，删除之后不必移动指针
                tmp.next= tmp.next.next
            else: ##不需删除，移动指针
                tmp = tmp.next
        return newhead.next
```

善于使用dummy head

#### 2. 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode*tmp1 = l1;
        ListNode*tmp2 = l2;
        ListNode* head = new ListNode(-1);
        ListNode* tmp = head;
        int carry = 0;
        while(tmp1 and tmp2){
            int digit = (tmp1->val+tmp2->val+carry) % 10;
            carry = (tmp1->val+tmp2->val+carry) / 10;
            tmp1 = tmp1->next;
            tmp2 = tmp2->next;
            cout<<digit;
            tmp->next = new ListNode(digit);
            tmp = tmp->next;
        }
        while(tmp1){
            int digit = (tmp1->val+carry) % 10;
            carry = (tmp1->val+carry) / 10;
            tmp1 = tmp1->next;
            tmp->next = new ListNode(digit);
            tmp = tmp->next;
        }
        while(tmp2){
            int digit = (tmp2->val+carry) % 10;
            carry = (tmp2->val+carry) / 10;
            tmp2 = tmp2->next;
            tmp->next = new ListNode(digit);
            tmp = tmp->next;
        }
        if(carry) tmp->next = new ListNode(carry);
        return head->next;

    }
};
```

【总结】链表类型的题，还是尽量用c++写吧...





## 链表排序

#### 148. 排序链表（归并排序）

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head; //递归边界
        
        ListNode* slow = head;
        ListNode* fast = head->next;
        while(slow && fast && fast->next){ //找中点
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* right = slow->next;
        slow->next = nullptr;
        ListNode* left = head;
        right = sortList(right);
        left = sortList(left);
        return merge(right,left);
        
    }
    ListNode* merge(ListNode* l1, ListNode* l2){  //合并两个有序链表
        ListNode* head = new ListNode(-1);
        ListNode* tmp = head;
        while(l1 && l2){
            if(l1->val < l2->val){
                tmp->next = l1;
                l1 = l1->next;
                tmp = tmp->next;
            }
            else{
                tmp->next = l2;
                l2 = l2->next;
                tmp = tmp->next;
            }
        }
        if(l1) tmp->next = l1;
        if(l2) tmp->next = l2;
        return head->next;
    }
};
```



#### 147. 对链表进行插入排序

为了插入方便，我们建立一个**dummy head**。然后，维护一个sorted区间，我们用`sort`变量指向sorted区间的末尾节点。`ptr`节点就指向sorted的下一个节点，那就是我们要插入到sorted区间的节点。

两种情况：

- 当ptr本身就已经比sorted大：那么说明可以直接移动sorted指针，之后的区间也必定有序
- 当ptr比sorted小：我们需要在这个位置删除ptr，然后把它插入到前面的合适位置。
  - 所谓“合适位置”，就是左边比它小、右边比它大的位置。
  - 插入完毕之后，sort指针不需要移动。

重复上述情况，直到sort.next为空。

```python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        def insert(head,node): ##把node插入到head后面
            head_next = head.next
            head.next = node
            node.next = head_next
        def remove(head): ##把head后面的node给remove掉
            node = head.next
            head_next_next = head.next.next
            head.next = head_next_next
            node.next = None
            return node ##返回一个孤零零的node

        new_head = ListNode(-5001)
        new_head.next = head
        sort = head
        while sort and sort.next:
            ptr = sort.next
            if ptr.val >= sort.val: ##不需要插入
                sort = sort.next
            else: ##需要插入
                node = remove(sort)
                tmp = new_head
                while tmp != sort:
                    if tmp.val <= ptr.val and ptr.val <= tmp.next.val: ##待插入位置
                        insert(tmp,node)
                        break
                    tmp = tmp.next
        return new_head.next
```

