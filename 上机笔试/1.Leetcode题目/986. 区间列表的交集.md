#### [986. 区间列表的交集](https://leetcode-cn.com/problems/interval-list-intersections/)

难度中等248

给定两个由一些 **闭区间** 组成的列表，`firstList` 和 `secondList` ，其中 `firstList[i] = [starti, endi]` 而 `secondList[j] = [startj, endj]` 。每个区间列表都是成对 **不相交** 的，并且 **已经排序** 。

返回这 **两个区间列表的交集** 。

形式上，**闭区间** `[a, b]`（其中 `a <= b`）表示实数 `x` 的集合，而 `a <= x <= b` 。

两个闭区间的 **交集** 是一组实数，要么为空集，要么为闭区间。例如，`[1, 3]` 和 `[2, 4]` 的交集为 `[2, 3]` 。

 

**示例 1：**

```
输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

**示例 2：**

```
输入：firstList = [[1,3],[5,9]], secondList = []
输出：[]
```



思路：

这种求区间交集的题目，都需要排序之后按照队列/栈取出头部，看能否合并。

```python
class Solution:
    def intervalIntersection(self, firstList, secondList):
        ans = []
        def compute_union(first,second): ##判断是否可以合并
            left = max(first[0],second[0]) ##左边界就是两者左边界的较大值
            right = min(first[1],second[1]) ##右边界就是两者右边界的较小值
            if left <= right:
                return True,[left,right] ##可以合并
            else:
                return False,[] ##不可以合并

        while len(firstList) and len(secondList):
            first_top = firstList[0]
            second_top = secondList[0]
            can_combine, result = compute_union(first_top,second_top)
            if not can_combine:
                if first_top[1] < second_top[0]:
                    firstList = firstList[1:] ##模拟队列
                else:
                    secondList = secondList[1:]
            else:
                ans.append(result)
                if first_top[1] < second_top[1]:
                    firstList = firstList[1:]
                else:
                    secondList = secondList[1:]
        return ans
```

