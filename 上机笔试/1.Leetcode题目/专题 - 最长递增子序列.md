# 专题 - 最长递增子序列

【求最长递增子序列长度（LIS问题）】

dp，每个位置记录以它为结尾的最长递增子序列。

```python
class Solution:
    def lengthOfLIS(self, nums) -> int:
        n = len(nums)
        dp = [1]*n ##初始化为1，不为0.
        for i in range(1,len(nums)):
            mmax = 1
            for j in range(i):
                if nums[j] < nums[i]:
                    mmax = max(mmax,dp[j]+1)
            dp[i] = mmax
        max_ans = 1
        for i in range(n): ##遍历数组才能找到最大的
            max_ans = max(max_ans,dp[i])
        return max_ans
```

【引申】如果让输出最长递增子序列呢？

其实也很简单，就是用marker数组，当每次最大值mmax发生变化的时候，就说明这个位置的最长子序列发生了更新，那么就应该记录marker。

```python
class Solution:
    def lengthOfLIS(self, nums) -> int:
        n = len(nums)
        dp = [1]*n
        marker = [0]*n ##标记
        for i in range(1,len(nums)):
            mmax = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    if dp[j] > mmax:
                        mmax = dp[j]
                        marker[i] = j
                dp[i] = mmax + 1
        max_lis = 1
        max_idx = 0 ##最长子序列的末尾
        for i in range(len(nums)):
            if dp[i] > max_lis:
                max_lis = dp[i]
                max_idx = i
        lis_list = []
        idx = max_idx
        while idx:##往回找
            lis_list.append(nums[idx])
            idx = marker[idx]
        return max_lis
```





#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

难度中等587

给定一个未排序的整数数组 `nums` ， *返回最长递增子序列的个数* 。

**注意** 这个数列必须是 **严格** 递增的。

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

**题解：**

先把最长递增子序列的默写一遍qwq, 然后再此基础上进行修改。

例如下面的例子中，要求7之前的最长递增子序列个数。可以看到，7之前有两个位置都符合”最长“递增子序列的标准，那么就应该把这两个结尾位置对应的个数都加起来。

![img](https://pica.zhimg.com/80/v2-16006a3e4d2d695c5c00f58963ce5e43_1440w.png)

```python
class Solution:
    def findNumberOfLIS(self, nums):
        n = len(nums)
        dp = [1]*n ##初始化为1，不为0.
        lis_num = [1]*n
        
        for i in range(1,len(nums)):
            mmax = 1
            for j in range(i):
                if nums[j] < nums[i]:
                    mmax = max(mmax,dp[j]+1)
            dp[i] = mmax
            lis_cnt = 0
            for j in range(i):
                if nums[j] < nums[i] and dp[j] == mmax - 1:
                    lis_cnt += lis_num[j]
            lis_num[i] = max(1,lis_cnt)
        max_ans = 1
        
        for i in range(n): ##遍历数组才能找到最大的
            max_ans = max(max_ans,dp[i])
        cnt = 0
        for i in range(n):
            if dp[i] == max_ans:
                cnt += lis_num[i]

        return cnt
```

