# 专题 - 最长递增子序列

#### 最长递增子序列长度（LIS问题）

dp，每个位置记录以它为结尾的最长递增子序列。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1]*len(nums) ##初始化为1
        ans = 1
        for i in range(1,len(nums)):
            mmax = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    mmax = max(mmax,dp[j]) ##找到最大的dp值
            dp[i] = mmax+1
            ans = max(ans,dp[i])
        return ans
```

【引申】如果让**输出**最长递增子序列呢？

其实也很简单，就是用marker数组，当每次最大值mmax发生变化的时候，就说明这个位置的最长子序列发生了更新，那么就应该记录marker。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1]*len(nums)
        ans = 1
        max_pos = -1 ##最长子序列的末尾
        marker = [-1]*len(nums) ##记录每个位置的前一个
        for i in range(1,len(nums)):
            mmax = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    if dp[j] > mmax:
                        mmax = max(mmax,dp[j])
                        marker[i] = j
            dp[i] = mmax+1
            if dp[i] > ans: 
                ans = dp[i]
                max_pos = i ##记录最大LIS的末尾位置
        tmp = max_pos
        while tmp >= 0:
            print(nums[tmp])
            tmp = marker[tmp]
```

**O(nlogn)解法：贪心+二分查找**

考虑一个简单的**贪心**，如果我们要使上升子序列尽可能的长，则我们需要**让序列上升得尽可能慢**，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]=nums[0]。

同时我们可以注意到 d[i]是关于 i单调递增的。

我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 nums[i]>d[len] 则更新 len = len + 1，否则在d[1…len]中找满足 d[i−1]<nums[j]<d[i] 的下标 ii，并更新d[i]=nums[j]。

根据 d数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        d = []
        for n in nums:
            if not d or n > d[-1]:
                d.append(n)
            else:
                l, r = 0, len(d) - 1
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        r = mid - 1
                    else:
                        l = mid + 1
                d[l] = n
        return len(d)
```



#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

难度中等587

给定一个未排序的整数数组 `nums` ， *返回最长递增子序列的个数* 。

**注意** 这个数列必须是 **严格** 递增的。

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

**题解：**

先把最长递增子序列的默写一遍qwq, 然后再此基础上进行修改。

例如下面的例子中，要求7之前的最长递增子序列个数。可以看到，7之前有两个位置都符合”最长“递增子序列的标准，那么就应该把这两个结尾位置对应的个数都加起来。

![img](https://pica.zhimg.com/80/v2-16006a3e4d2d695c5c00f58963ce5e43_1440w.png)

```python
class Solution:
    def findNumberOfLIS(self, nums):
        n = len(nums)
        dp = [1]*n ##初始化为1，不为0.
        lis_num = [1]*n
        
        for i in range(1,len(nums)):
            mmax = 1
            for j in range(i):
                if nums[j] < nums[i]:
                    mmax = max(mmax,dp[j]+1)
            dp[i] = mmax
            lis_cnt = 0
            for j in range(i):
                if nums[j] < nums[i] and dp[j] == mmax - 1:
                    lis_cnt += lis_num[j]
            lis_num[i] = max(1,lis_cnt)
        max_ans = 1
        
        for i in range(n): ##遍历数组才能找到最大的
            max_ans = max(max_ans,dp[i])
        cnt = 0
        for i in range(n):
            if dp[i] == max_ans:
                cnt += lis_num[i]

        return cnt
```







#### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

难度中等445

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

题解：

使用类似LIS的dp方法，每个位置记录以它为结尾的上升子序列，在dp的时候每个位置都会考察前面比它小的那些位置的上升序列

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        dp = [[] for _ in range(len(nums))]
        ans_list = []
        dp[0] = [[nums[0]]]
        for i in range(1,len(nums)):
            ans = [[nums[i]]]
            for j in range(i):
                if nums[j] <= nums[i]:
                    prev_ans = dp[j]
                    for item in prev_ans:
                        ans.append(item+[nums[i]])
            dp[i] = ans
            for item in ans:
                if len(item) >= 2 and item not in ans_list:
                    ans_list.append(item)
        return ans_list
```

