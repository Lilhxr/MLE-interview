#### [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

难度中等56

给你一个二进制数组 `nums` ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

 

**提示 1：**

```
输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。
```



题解：我们直接求出每个区间1的个数，用双指针来求。之后看看有没有可以合并的两个区间。

```python
class Solution:
    def longestSubarray(self, nums) -> int:
        for i in range(0,len(nums)):
            if nums[i] == 1: ##找到第一个1
                break
        left_ptr = i; right_ptr = i
        interval = []
        while left_ptr < len(nums) and right_ptr < len(nums):
            while right_ptr < len(nums) and nums[right_ptr] == 1: ##还在1的范围内
                right_ptr+=1
            if left_ptr == 0 and right_ptr == len(nums): ##解决[1,1,1,1]测例
                return len(nums)-1
            interval.append((left_ptr,right_ptr))
            left_ptr = right_ptr
            while left_ptr < len(nums) and nums[left_ptr] == 0: ##在0的范围内
                left_ptr += 1
                right_ptr+=1
        ans = 0
        for i in range(len(interval)):
            ans = max(ans,interval[i][1]-interval[i][0])
            if i >= 1 and interval[i][0]-interval[i-1][1] <= 1:
                ans = max(ans, interval[i][1]-interval[i-1][0]-1)
        return ans
```

