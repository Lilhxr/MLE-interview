# 146. LRU缓存

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：

- LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
- void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
  函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。



【思路】

key-value对->想到哈希表

但是题目要求put和get时间复杂度都为O(1). 如果想要快速调整LRU的顺序，肯定需要**链表**（可以在O(1)时间插入、删除）。但是链表又不支持**随机访问**，怎么办呢？那就可以用哈希表给每个key记录链表节点：
  ![img](https://pic2.zhimg.com/80/v2-61dcf813c8f586895ac9c40789d68c77_1440w.png)


  首先，定义链表节点：

```python
class ListNode:
    def __init__(self,value,key):
        self.value = value
        self.key = key ##注意这里也要记录key
        self.next = None
        self.prev = None
```

注意，python的类定义格式！！要写**"self."**, 函数名称为 \_\_init\_\_() .

然后，定义LRU整个的数据结构：

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity  ###容量，超过此容量就需要LRU替换了
        self.head = ListNode(-1,-1)
        self.tail = ListNode(-1,-1)
        self.head.next = self.tail
        self.tail.prev = self.head  ###由于涉及到头插入、尾删除，所以需要头尾哨兵
        self.hash_table = {} ##记录key->ListNode
```

 还有两个辅助函数，插入和删除，因为之后要重复使用这两个函数：

插入头部：

```python
    def insert(self,node,head):
        head_next = head.next
        head.next = node
        node.prev = head
        node.next = head_next
        head_next.prev = node
        return head
```

删除一个节点：

```python
    def remove(self,head,node):
        node_prev = node.prev
        node_next = node.next
        node_prev.next = node_next
        node_next.prev = node_prev
        return head
```

get函数：

```python
    def get(self, key: int) -> int: ##直接从哈希表中找，O(1). 
        if key in self.hashtable.keys() and self.hashtable[key]!=None:
            self.remove(self.head,self.hashtable[key]) ##移到最前面
            self.insert(self.hashtable[key],self.head)
            return self.hashtable[key].val
        else:
            return -1
```



put函数：

```python
def put(self, key: int, value: int) -> None:
        if key in self.hashtable.keys() and self.hashtable[key]!=None:
            node = self.hashtable[key]
            node.val = value ###变更value值
            self.head = self.remove(self.head,node) ##移到list最前面
            self.head = self.insert(node,self.head)
        else:
            node_new = Listnode(value,key) ##创建新节点
            self.insert(node_new,self.head) ##插入头部
            self.hashtable[key] = node_new ##创建对应的dic索引
            self.size += 1
            if self.size > self.capacity: ##超过capacity
                self.hashtable[self.tail.prev.key] = None ##删除末位的索引
                self.remove(self.head,self.tail.prev) ##删除末位
                
```
