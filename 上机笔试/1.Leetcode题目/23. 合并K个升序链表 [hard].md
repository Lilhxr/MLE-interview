#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) [hard]

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

解法：

类似合并两个链表，总共需要K个指针，每次取这些指针里面最小的那个（用堆优化），然后最小的那个对应指针右移。**直到堆为空。**

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        K = len(lists)
        head0 = ListNode(-1) ##为了不新建节点，需要【改变节点间链接关系】
        tmp = head0
        ptr_list = [lists[i] for i in range(K)] ##初始状态都指向链表头
        heap = []
        for i in range(K): ##建最小堆
            if lists[i]:
                heap.append([lists[i].val,i]) ##记录是哪个链表
        heapq.heapify(heap)
        
        while len(heap):
            top = heap[0]
            top_idx = heap[0][1]
            heapq.heappop(heap) ##取最小值
            tmp.next = ptr_list[top_idx]
            ptr_list[top_idx] = ptr_list[top_idx].next
            tmp = tmp.next
            if ptr_list[top_idx]:
                heapq.heappush(heap,[ptr_list[top_idx].val,top_idx])
        return head0.next
```

