# 297. 二叉树的序列化和反序列化 [hard]



序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

 

题解：

对于序列化，我们直接用**先序遍历**。但是，先序遍历不是不能够恢复二叉树的嘛？甚至连二叉搜索树都恢复不了呀。其实，这里的“先序遍历”是**记录了空节点的先序遍历**，例如下图的二叉树被记录为[1,2,None,None,3,4,None,None,5,None,None]. 那么这个序列是可以恢复出完整的二叉树的！

具体的恢复方法就是，对于这个序列，每次都拿出最前面的那个当作根（当然如果是None的话就直接返回）；然后pop掉第一个位置的值，开始恢复左节点、恢复右节点。

![image.png](https://pic.leetcode-cn.com/f009a6fa08e46c1e9d0f803870e823af89c14cf48a7a7da9fced4cec5033c31c-image.png)

```python
class Codec:
    pre_order = []
    def serialize(self, root): ##记录先序遍历序列
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        self.pre_order = []
        self.helper(root)
        return "@".join(self.pre_order)
    def helper(self,root):###先序遍历
        if not root:
            self.pre_order.append("None")
            return
        self.pre_order.append(str(root.val))
        self.helper(root.left)
        self.helper(root.right)
        
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        data = data.split("@")
        self.data = data
        return self.reconstruct()
    def reconstruct(self):
        val = self.data[0]
        self.data = self.data[1:]
        if val == 'None':
            return None
        root = TreeNode(int(val))
        root.left = self.reconstruct()
        root.right = self.reconstruct()
        return root
```

注意在恢复二叉树的时候，需要记录一个全局能够访问的列表self.data, 因为每次需要修改这个self.data.