# 双指针相关

模板：

```python
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int left_ptr = 0; ##左指针指向头
        int right_ptr = 0; ##右指针指向头
        int cnt = 0;
        int min_len = INT_MAX;
    
        while(right_ptr < n){ ##右指针不出界
            cnt += nums[right_ptr]; ##加上右指针对应的值
            right_ptr++; ##右窗口移动
            while(cnt >= target){ ##符合条件了！
                min_len = min(min_len,right_ptr-left_ptr);
                cnt -= nums[left_ptr]; ##减去左指针对应的值
                left_ptr++; ##左窗口移动
            }
        }
        if(min_len == INT_MAX) return 0;
        return min_len;
    }
};
```


#### 3. 无重复字符的最大子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

```python
示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```



两个指针都指向头，右指针向后移动，直到发现重复的字符。然后左指针才能够右移。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        def has_dup(dic): ###dic中如果有>=2者，返回true
            for key in dic.keys():
                if dic[key] >= 2:
                    return True
            return False
        dic = {}
        left = 0; right = 0
        mmax = 0
        while left < len(s) and right < len(s):
            ####可以直接无脑移动右指针
            if s[right] not in dic.keys():
                dic[s[right]] = 1
            else:
                dic[s[right]] += 1
            right += 1
            while has_dup(dic): ##发现重复了！
                mmax = max(mmax,right-left-1)
                dic[s[left]]-= 1
                left += 1
        mmax = max(mmax,right-left)
        return mmax
```

【双指针易错点1】在双指针问题中，移动左右指针的步骤"right_ptr+=1"和"left_ptr+=1"都需要放在最后！！不然的话left_ptr和right_ptr都发生了变化就不对了。

【双指针易错点2】while之后一般还需要做一次判断，就如代码倒数第二行`mmax = max(mmax,right-left)`.

【本题易错点】while之后，实际为从left到末尾都没有重复之意，所以不用-1；而while中为此时刚好有重复之意，所以需要-1.



#### 76. 最小覆盖子串 [hard]

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```



使用双指针。由于字典中只记录了英文字符，所以判断t中字符是否都被s包含的复杂度是O(1)的。我们只需用两个指针遍历s，一旦发现可以包含就记录，同时右移左指针；否则就一直右移右指针。

```python
class Solution:
    def contains(self,s_dic,t_dic):  ##如果t_dic中的所有字符都被s_dic包含，返回true
        for key in t_dic.keys():
            if s_dic[key] < t_dic[key]:
                return False
        return True

    def minWindow(self, s: str, t: str) -> str:
        mmin = 100000000000
        ans = ""
        dic = {}
        s_dic = {}
        alphabet = "qwertyuiopasdfghjklzxcvbnm"
        for i in range(len(alphabet)):
            dic[alphabet[i]] = 0
            dic[alphabet[i].upper()] = 0
            s_dic[alphabet[i]] = 0
            s_dic[alphabet[i].upper()] = 0
        for i in range(len(t)):
            dic[t[i]] += 1

        left = 0
        right = 0
        while(left < len(s) and right < len(s)):
            s_dic[s[right]] += 1
            right += 1
            while(self.contains(s_dic,dic)): ##发现符合条件的了！
                if right - left < mmin: ##记录答案
                    mmin = right-left
                    ans = s[left:right]
                s_dic[s[left]]-=1 ##右移left
                left+=1
        return ans
```





#### [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

难度中等564

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回包含相同字母的最长子字符串的长度。

 

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

首先，只要当前的区间长度 <= 字典中出现最多的那个元素出现的次数 + k，我们就可以一直移动右指针；直到条件不成立，再移动左指针。

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        n = len(s)
        left = 0; right = 0
        dic = {}
        mmax = 0
        while left < n and right < n:
            while len(dic) == 0 or right - left <= max(dic.values()) + k:
                mmax = max(mmax,right-left)
                if right >= n:###防止出界
                    break
                if s[right] in dic.keys():##移动右指针
                    dic[s[right]] += 1
                else:
                    dic[s[right]] = 1
                right += 1
            dic[s[left]] -= 1
            left+=1
        return mmax
```





#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

难度中等597

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

**示例 1：**

```
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

解法：【固定窗口长度的滑动窗口】

最不容易出错的做法就是，**先做好第一个窗口**，然后不断地像量尺虫一样向前移动(left++,right++).

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        def is_equal(dic1,dic2):
            for i in dic1.keys():
                if dic1[i]!=dic2[i]:
                    return False
            return True
        len1 = len(s1)
        len2 = len(s2)
        if len2 < len1:
            return False
        alphabet = "qwertyuiopasdfghjklzxcvbnm"
        dic1 = {}
        dic2 = {}
        for i in alphabet:
            dic1[i] = 0
            dic2[i] = 0

        for i in range(len(s1)):
                dic1[s1[i]] += 1
        left = 0
        right = 0
        for right in range(len1):
            dic2[s2[right]] += 1
        if is_equal(dic1,dic2):
            return True
        while right < len(s2)-1:
            dic2[s2[left]] -= 1
            left += 1
            right += 1
            dic2[s2[right]] += 1
            if is_equal(dic1,dic2):
                return True
        return False
```



##### 151. 翻转字符串中单词

示例 1：

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

示例 2：

```
输入：s = "  hello world  "
输出："world hello"
解释：颠倒后的字符串中不能存在前导空格和尾随空格。
```

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip()
        i = 0
        j = 0
        BLANK = " "
        ans = []
        while i < len(s) and j < len(s):
            while j < len(s) and s[j] != BLANK: ##不是空格，就不停右移右指针
                j += 1
            ans.insert(0,s[i:j])
            i = j ##“量尺虫”
            while i < len(s) and j < len(s) and s[i] == BLANK and s[j] == BLANK: ##空格，同时移动两个指针
                i += 1; j += 1
        return " ".join(ans)
```

