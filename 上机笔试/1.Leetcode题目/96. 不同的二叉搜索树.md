#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 ![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

**示例 1：**

```
输入：n = 3
输出：5
```

解法：

使用带记忆化的dfs。节点值1-n的二叉搜索树个数，可以将其分解为左、右子树，这样问题规模就缩小了。那么，我们去枚举根节点是1-n的这n种情况，并计算左、右子树的可能情况。

例如考虑节点编号1-5的二叉搜索树：`1,2,3,4,5`. 那么root可以为1,2,3,4,5. 

```python
class Solution:

    def numTrees(self, n: int) -> int:
        self.dp = [-1]*(n+1)
        self.dp[1] = 1
        self.dp[0] = 1

        return self.dfs(n)
       
    def dfs(self,n): ##n个节点组成的二叉搜索树个数
        if n == 1:
            return 1
        if n == 0:
            return 1
        ans = 0
        for root in range(1,n+1): ##根节点的idx
            left_num = root-1
            right_num = n-root
            if self.dp[left_num] == -1:
                self.dp[left_num] = self.dfs(left_num) ##记忆
            if self.dp[right_num] == -1:
                self.dp[right_num] = self.dfs(right_num)
            ans += self.dp[left_num]*self.dp[right_num]
        return ans 

```

