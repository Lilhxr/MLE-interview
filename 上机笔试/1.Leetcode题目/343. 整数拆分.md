#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

难度中等788

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



答案：

dp或者带记忆化的搜索

```python
class Solution:
    dp = None
    def integerBreak(self, n: int) -> int:
        self.dp = [-1]*(n+1)
        def dfs(n):  ###n的最大乘积
            if n == 0 or n == 1:
                return n
            if self.dp[n] != -1:
                return self.dp[n]
            ans = 0
            for i in range(1,n+1):
                ans = max(ans,dfs(n-i)*i,(n-i)*i)
            self.dp[n] = ans
            return ans
        return (dfs(n))
```

【易错点】：

n*1不能作为一个合法的乘积。例如3的最大乘积是2而不是3. 

应该是`ans = max(ans,dfs(n-i)*i,(n-i)*i)`, 而不能把(n-i)*i丢掉。因为前面的n-i可以选择不去划分。