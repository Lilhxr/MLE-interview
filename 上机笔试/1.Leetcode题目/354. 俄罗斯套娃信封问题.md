#### [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

难度困难737

给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**注意**：不允许旋转信封。

**示例 1：**

```
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```





前言

同时控制 ww 和 hh 两个维度并不是那么容易，因此我们考虑固定一个维度，再在另一个维度上进行选择。例如，我们**固定 ww 维度**，那么我们将数组 envelopes 中的所有信封按照 w 升序排序。然而小于等于 和小于 还是有区别的，但我们不妨首先考虑一个简化版本的问题：

如果我们保证所有信封的 ww 值互不相同，那么我们可以设计出一种得到答案的方法吗？

在 ww 值互不相同的前提下，小于等于 \leq≤ 和小于 << 是等价的，那么我们在排序后，就可以完全忽略 ww 维度，只需要考虑 hh 维度了。此时，我们需要解决的问题即为：

给定一个序列，我们需要找到一个最长的子序列，使得这个子序列中的元素严格单调递增，即上面要求的：

h_0 < h_1 < \cdots < h_{k-1}
h 
0

 <h 
1

 <⋯<h 
k−1

 

那么这个问题就是经典的「最长严格递增子序列」问题了，读者可以参考力扣平台的 300. 最长递增子序列 及其 官方题解。最长严格递增子序列的详细解决方法属于解决本题的前置知识点，不是本文分析的重点，因此这里不再赘述，会在方法一和方法二中简单提及。

当我们解决了简化版本的问题之后，我们来想一想使用上面的方法解决原问题，会产生什么错误。当 ww 值相同时，如果我们不规定 hh 值的排序顺序，那么可能会有如下的情况：

排完序的结果为 [(w, h)] = [(1, 1), (1, 2), (1, 3), (1, 4)][(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的 ww 值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 11 个信封。然而如果我们完全忽略 ww 维度，剩下的 hh 维度为 [1, 2, 3, 4][1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的 44 个信封了，这就产生了错误。

因此，我们必须要保证对于每一种 ww 值，我们最多只能选择 11 个信封。

我们可以将 hh 值作为排序的第二关键字进行降序排序，这样一来，对于每一种 ww 值，其对应的信封在排序后的数组中是按照 hh 值递减的顺序出现的，那么这些 hh 值不可能组成长度超过 11 的严格递增的序列，这就从根本上杜绝了错误的出现。

因此我们就可以得到解决本题需要的方法：

首先我们将所有的信封按照 ww 值第一关键字升序、hh 值第二关键字降序进行排序；

随后我们就可以忽略 w 维度，**求出 h 维度的最长严格递增子序列，其长度即为答案。**



题解：

```python
import functools

class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key = lambda x: (x[0],-x[1]))
        height = [x[1] for x in envelopes]
        d = []
        for n in height:
            if not d or n > d[-1]:
                d.append(n)
            else:
                l, r = 0, len(d) - 1
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        r = mid - 1
                    else:
                        l = mid + 1
                d[l] = n
        return len(d)
```

